\head{Тестирование}
Если написанный код всё же работает, то он может, к сожалению, работать не правильно, так что приходится искать когда он ломается. Попробуем перечислить способы тестирования.

\begin{enumerate}
    \item Во-первых, самый простой способ -- проверить на тестовых данных и разобрать вручную какие-то свои примеры и прогнать их. Способ конечно хороший и помогает понять, происходит ли то, что планировалось, или есть какие-то проблемы. Иногда, при составлении своих тестов, приходит понимание, что придумали не правильный алгоритм, и становится понятно, что нужно придумать другой. Так что делать свои тесты стоит, и не занимает много времени.

    \item Второй важный тип тестов -- крайние случаи. Это могут быть какие-то минимальные, максимальные входные данные, или просто данные со сложной структурой. В маленьких тестах можно разобраться самим, в больших же можно проверить, что программа не ломается и выводит что-то похожее на правду. Тут уже становится видно, что на больших тестах программу как-то сложно тестировать, а хотелось бы. Генерировать большие тесты можно с помощью скриптов, это мы обсудим дальше.

    \item И третий тип тестов -- когда тесты достаточно большие чтобы хорошо покрыть разные случаи, и при этом мы откуда-то знаем правильные ответы на них. Это называется стресс-тестированием и вам нужно: генератор рандомных тестов, точно правильное решение (но не оптимальное, например по времени), решение с багом (быстрое, но немного не правильное). Это ещё называется стресс-тестированием: генерируете случайные тесты и даёте их на вход двум решениям, потом сравниваете ответы. Эти части опять же хорошо делаются с помощью скриптов, которые как-то взаимодействуют друг с другом.

    \item И плохой способ тестировать, но теоретически так можно заифать хоть все тесты. В общем-то суть простая: добавляете разные проверки на входные данные, выполнение которых приводит к разные результатам (проще всего получать WA и RE) -- и отсылаете это в тестирующую систему. Так постепенно можно узнать что-то про тест и проверять его локально. Такое конечно могут признать <<дестабилизацией тестирующей системы>>, так что применять метод не рекомендую.
\end{enumerate}

Нам придётся взаимодействовать с консолью, так что какие-то маленькие её возможности придётся знать. Самый главный примитив -- запуск программы, в консоли его можно делать так \lsh{prog_name < in.txt > out.txt} -- это запустит бинарный файл \lsh{prog_name} с вводом из файлы \lsh{in.txt} и выводом в \lsh{out.txt}, какой-то из файлов можно не указывать (для Linux нужно здесь и далее нужно писать \lsh{./prog_name}). Если хочется запустить не бинарный файл \lsh{prog_name}, а например Python-скрипт, то нужно использовать \lsh{python script.py < in.txt > out.txt} (вместо \lsh{python} может быть придётся писать \lsh{py} или \lsh{python3} в зависимости от настроек системы).

Если считать, что файлы \lsh{gen.py}, \lsh{slow}, \lsh{fast} находятся в директории со скриптом, то всю логику тестирования можно довольно компактно написать на Python. Если мы считаем, что вывод должен совпасть целиком (со всеми пробелами и переносами строк), то можем просто сравнивать результаты работы программ.

\py{infra/testing}{31}

Если же возможных ответов несколько, то проверку нужно писать каким-то более умным способом (чувствуете теперь, какого авторам задач всё это делать). Кстати, про авторство задач, если у вас есть архив со всеми фалами к задаче, то можно скомпилировать авторское решение и запускать на авторских тестах, используя чекер автора. Конечно, бывают ещё и интерактивные задачи, но они редки, так что не стоит ради них заморачиваться с тестированием, но при желании конечно можно разобраться самостоятельно.

И теперь приведём пример какого-нибудь простого генератора, чтобы у читателя было примерное понимание как они выглядят. Можно писать генераторы не на Python, а например на том же C++, просто нужно понимать, какой язык лучше использовать для каких целей. Сгенерируем случайное число, строку и массив:

\py{infra/testing}{23}

Конечно, на первый взгляд тестирование штука сложная, но по жизни полезная :)
