\head{Алгебра, часть 2}
В этом блоке мы продолжим изучать алгоритмы теории чисел, которые очень удобно вычислять с помощью компьютера. Все алгоритмы из этого блока будут так или иначе основываться на разложении числа на простые множители.


\subhead{Проверка на простоту}
Как мы узнали в самом начале, числа бывают простыми и составными. И хотелось бы как-нибудь проверить, какое число каким является.

Понятно, как проверить за \O{n} — просто перебрать все числа, которые меньше заданного $n$ и проверить, являются ли они делителями. Но такой способ не оптимален и можно действовать чуть быстрее.

Для этого вспомни (или узнаем), что если число составное, то у него не просто есть делители, но и какие-то из них обязательно не больше, чем $\sqrt{n}$. В самом деле, пусть все делители больше, чем $\sqrt{n}$, тогда возьмём какой-то из них $d > \sqrt{n}$. Но ведь когда мы поделим получится $\frac{n}{d} = d'$, при этом $d'$ — целое, а значит тоже делитель. Остаётся только осознать, что будет выполнено неравенство: $d' < \sqrt{n}$ и мы всё же найдём делитель, меньший корня.

А раз так, то перебирать можно не все число, а только до корня и сложность такого алгоритма составит \O{\sqrt{n}}. Этот алгоритм и нужно реализовать читателю :)


\subhead{Решето Эратосфена}
Хорошо, для одного числа мы смогли определить, простое оно, или составное. Но что делать, если у нас такую проверку нужно осуществить для диапазона чисел от $1$ до $n$?

Конечно, можно каждое число проверить на простоту и получить сложность \O{n^2} при наивной проверке на простоту и \O{n\sqrt{n}} при оптимизированной проверке. Но оказывается, что \term{Решето Эратосфена} способно быстрее решать эту задачу. Суть этого алгоритма проста:

\begin{box-algo}
    \begin{enumerate}
        \item Выпишем все числа из нашего диапазона (от $1$ до $n$).
        \item Единицу сразу зачеркнём, ведь она по определению не простая.
        \item Далее для всех чисел в порядке возрастания будем проводить следующую операцию. Пусть очередное число — $d$, тогда:
            \begin{itemize}
                \item Если очередное число зачёркнуто, то оно не простое и можно перейти к следующему числу.
                \item Если же очередное число ($x$) не зачёркнуто, то оно простое и нужно зачеркнуть все числа, которые на него делятся: $2x, 3x, \ldots kx, \ldots$ ($k \in \set{N}, k > 1$). И понятно, что закончить зачёркивание нужно, когда мы дойдём до конца выписанного диапазона (до $n$). После этого переходим к следующему числу.
            \end{itemize}
        \item Теперь все не зачёркнутые числа — простые, зачёркнутые (кроме $1$) — составные.
    \end{enumerate}
\end{box-algo}

При этом в алгоритме можно сделать улучшение — вычёркивать все числа, делящиеся на простое $x$ можно не от $2x$, а от $x^2$, так как все числа меньшие $x^2$ точно имеют делитель, не превосходящий их корня, а значит меньший $x$. И сложность алгоритма после оптимизации составит \O{n \log\log n}.


\subhead{Факторизация}
Факторизацией называется разложение числа на простые множители, то есть получение выражения вида: $n = p_1^{\alpha_1} \cdot p_2^{\alpha_2} \cdot \ldots \cdot p_s^{\alpha_s}, p_i \in \set{P}, \alpha_i \in \set{N}$.

Алгоритм факторизации напоминает алгоритм проверки на простоту: перебираем потенциальные делители, и если число $n$ делится нацело на очередной делитель $x$, то мы делим на это $x$ и добавляем его в разложение, и повторяем эту операцию, пока $n$ продолжает делиться на $x$. Остановить же алгоритм можно, когда на очередном шаге станет $x > \sqrt{n}$, ведь тогда мы знаем, что числа, меньшие оставшегося $\sqrt{n}$ точно не являются его делителями, а значит, наше число $n$ либо 1, либо простое.

При этом, сохранять разложение можно любым удобным способом: с помощью \lcpp{vector} или с помощью \lcpp{map}.

Сложность алгоритма факторизации составляет \O{\sqrt{n}}, если просто перебирать все потенциальные делители. Но понятно, что можно перебирать только простые делители, поэтому в случае использования решета Эратосфена можно достичь сложности \O{\pi(\sqrt{n})}, где $\pi(m) < O\left(\frac{m}{\ln(m) - 1}\right)$ — количество простых чисел, меньших $m$.


\subhead{Функция делителей}
В математике придумали \term{функцию делителей}, которая задаётся формулой: $\sigma_x(n) = \sum d^x$, где $n \div d$.

Понятную практическую пользу функция делителей имеет при $x = 0$ — количество делителей, и $x = 1$ — сумма делителей. Именно их мы и научимся вычислять.

Первый способ, очевидный, таков: перебираем все потенциальные делители до корня. Если число $n$ делится на очередной потенциальный делитель $x$, то к сумме добавляем $x + \frac{n}{x}$. а к количеству — $2$. Отдельный случай, когда $x = \sqrt{n}$ — тогда $x$ и $\frac{n}{x}$ совпадают, поэтому к сумме нужно прибавить $x$, а к количеству — $1$.

Но второй способ, связанный с факторизацией, чуть более интересный. Он заключается в использовании следующий наблюдений из теории чисел:

\begin{itemize}
    \item Пусть $n = p_1^{\alpha_1} \cdot p_2^{\alpha_2} \cdot \ldots \cdot p_s^{\alpha_s}, p_i \in \set{P}, \alpha_i \in \set{N}$, тогда:
    \item $\sigma_0(n) = (\alpha_1 + 1) \cdot (\alpha_2 + 2) \cdot \ldots \cdot (\alpha_s + 1)$. Это равенство является верным, потому что мы можем получать делители числа $n$ из разложения на простые множители, ведь у всех делителей $p_i$ обязательно в степени $0, 1 \ldots \alpha_i$, а значит всего способов составить делители именно столько, сколько получит эта формула.
    \item $\sigma_1(n) = (1 + p_1^1 + p_1^2 + \ldots + p_1^{\alpha_1}) \cdot (1 + p_2^1 + p_2^2 + \ldots + p_2^{\alpha_2}) \cdot \ldots \cdot (1 + p_s^1 + p_s^2 + \ldots + p_s^{\alpha_s})$. Убедиться в верности данной формулы можно с помощью раскрытия скобок. Но видно, что в такой записи использовать формулу не удобно, поэтому её можно упростить, преобразовав выражения в скобках: $\sigma_1 = \frac{p_1^{\alpha_1 + 1} - 1}{p_1 - 1} \cdot \frac{p_2^{\alpha_2 + 1} - 1}{p_2 - 1} \cdot \ldots \cdot \frac{p_s^{\alpha_s + 1} - 1}{p_s - 1}$.
    \item Также можно заместить, что $\sigma_0(n)$ и $\sigma_1(n)$ мультипликативные функции, потому что это видно по формулам для их вычисления.
\end{itemize}

Сложность вычисления функции делителей обоими представленными способами будет \O{\sqrt{n}}.


\hypertarget{euler_function}{}
\subhead{Функция Эйлера}
Будем называть числа $a$ и $b$ \term{взаимно простыми}, если их НОД равен 1 ($gcd(a, b) = 1$). \term{Функция Эйлера} ($\varphi(n)$) показывает количество чисел, меньше данного, и взаимно простых с ним. При этом $\varphi(1) = 1$, так как $gcd(1, 1) = 1$.

Вычисляется функций Эйлера по формуле: $\varphi(n) = (p_1^{\alpha_1} - p_1^{\alpha_1 - 1}) \cdot (p_2^{\alpha_2} - p_2^{\alpha_2 - 1}) \cdot \ldots \cdot (p_s^{\alpha_s} - p_s^{\alpha_s - 1})$. Для более удобного вычисления её можно преобразовать: $\varphi(n) = n \cdot (1 - \frac{1}{p_1}) \cdot (1 - \frac{1}{p_2}) \cdot \ldots \cdot (1 - \frac{1}{p_s})$.

Теперь докажем эту формулу. Во-первых, очевидно, что $\varphi(p^\alpha) = p^{\alpha} - p^{\alpha - 1} = p^{\alpha - 1} \cdot (p - 1)$, где $p \in \set{P}$.

Чуть сложнее доказать, что функция Эйлера мультипликативная. Для этого возьмём два взаимно простых числа $n$ и $m$, и будем доказывать, что $\varphi(n \cdot m) = \varphi(n) \cdot \varphi(m)$. Теперь запишем числа от $1$ до $n \cdot m$ в таблицу из $n$ строк и $m$ столбцов (в ячейке со строкой $i$ ($0 \leq i \leq n - 1$) и столбцом $j$ ($0 \leq j \leq m - 1$) запишем число $a_{i, j} = i \cdot m + j + 1$). Заметим, что если число взаимно просто с $n \cdot m$, то оно должно быть взаимно просто с $n$ и с $m$. Теперь вспомним, что в Алгоритме Евклида мы вычитали, поэтому, если какое-то число взаимно просто с $m$, то мы можем вычитать это $m$ и получать новые числа взаимно простые с $m$. Таким образом во всех столбцах числа будут или взаимно просты с $m$ или нет, а значит всего взаимно простых столбцов окажется $\varphi(m)$. Теперь рассмотрим какой-то из этих столбцов, пусть в нём сверху число $k$, тогда остальные числа это $m + k, 2m + k, \ldots, (n - 1)m + k$. Теперь заметим, что все остатки от деления этих на $n$ должны быть различны. В самом деле, пусть нашлись какие-то два одинаковых остатка ($(sm + k) \mod n = (tm + k) \mod n, s < t$), тогда их разность должна делиться на $n$: $(t - s)m \div n$. Но ведь $gcd(m, n) = 1$, значит $(t - s) \div n$, но тогда должно выполняться $(t - s) \geq n$, но это, очевидно, недостижимо. Значит у набора $k, m + k, 2m + k, \ldots, (n - 1)m + k$ все остатки должны быть различны, а значит это будут $0, 1, \ldots, n - 1$ (в каком-то перемешанном порядке). А мы знаем, что среди них ровно $\varphi(n)$ взаимно просты с $n$. То есть числа, которые взаимно просты с $n \cdot m$ располагаются в $\varphi(m)$ столбцах по $\varphi(n)$ штук в каждом, а значит всего их $\varphi(n \cdot m) = \varphi(n) \cdot \varphi(m)$, что и нужно было доказать.

Теперь совмещаем два этих наблюдения, и приходим к выводу, что $\varphi(n) = \varphi( p_1^{\alpha_1} \cdot p_2^{\alpha_2} \cdot \ldots \cdot p_s^{\alpha_s} ) = \varphi(p_1^{\alpha_1}) \cdot \varphi(p_2^{\alpha_2}) \cdot \ldots \cdot \varphi(p_s^{\alpha_s}) = (p_1^{\alpha_1} - p_1^{\alpha_1 - 1}) \cdot (p_2^{\alpha_2} - p_2^{\alpha_2 - 1}) \cdot \ldots \cdot (p_s^{\alpha_s} - p_s^{\alpha_s - 1})$, а это как раз та формула, что и была выше.

Сложность вычисления функции Эйлера указанным выше способом — \O{\sqrt{n}} (на факторизацию). Понятно, что можно просто перебрать все числа, меньшие $n$, но тогда сложность будет выше — \O{n}.

Применяется же функция Эйлера в теореме Эйлера, которая гласит, что $a^{\varphi(m)} \equiv 1 {\pmod{m}}$ для взаимно простых $a$ и $m$. Теорема Эйлера является обобщением МТФ и позволяет искать обратные числа по составным модулям (если число $m$ является простым, то мы как раз получаем формулировку МТФ).
