\head{Идеи проектирования алгоритмов}
В этом разделе мы посмотрим на важные идеи в проектировании алгоритмов, которые мы потом будем применять при решении задач. Они не дотягивают до самостоятельных задач, но очень хорошо используются в других задачах.

\begin{itemize}
    \item \term{Барьерный элемент}. Пусть у нас есть какой-то алгоритм, который иногда не находит ответы внутри нашего набора данных, и в таком случае нужно вывести какое-то специальное значение. Если мы не хотим обрабатывать такой случай отдельно, то можем добавить в наш набор данных какие-нибудь специальные значения (например, $\infty$ или $-\infty$), которые наш алгоритм сможет корректно обработать без внесения в него дополнительных условий.
    \item \term{Предподсчёт}. Иногда у нас в задаче есть какие-то входные данные, которые не будут меняться на протяжении всей задачи, и какие-то запросы, которые нужно обработать. Если нам для разных запросов нужно будет считать что-то несколько раз, то можно перед обработкой запросов вычислить нечто, что позволит быстро отвечать на все запросы. Такое вычисление перед обработкой самих запросов и называется предподсчётом.
    \item \term{Два указателя}. Если у нас есть какой-то набор данных, в котором мы работаем с отрезками, то давайте использовать два указателя на концы этого отрезка. И в зависимости от каких-то условий будем двигать либо левый указатель, либо правый в одну сторону (или всегда вправо, или всегда влево). Если задачу таким методом решить можно, то алгоритм будет работать довольно быстро, ведь каждый указатель пройдёт не больше, чем весь набор данных, а значит алгоритм будет линейным.
    \item \term{Сканирующая прямая (scanline)}. Пусть у нас есть какие-то события, которые нужно обработать. Тогда мы можем отсортировать эти события по времени (по порядку, в котором они проходят), и обработать в таком порядке. Например, можно использовать эту идею перед обработкой запросов, сделав предподсчёт ответов для всех возможных запросов.
    \item \term{Встреча в середине (meet in the middle)}. Пусть у нас есть какой-то алгоритм, который начинается в точке $A$, заканчивается в точке $B$ и посещает по пути какие-то другие точки $C_1,\ C_2,\ \ldots,\ C_n$ (например, путь коня по шахматной доске). При этом, требуется найти кратчайший путь между $A$ и $B$. Понятно, что проще всего выйти из $A$ и искать пусть к $B$, но может оказаться полезным искать такой путь не из одной вершины, а выйти одновременной из двух, чтобы встретиться в середине пути.
    \item \term{Переливания}. Пусть у нас есть $N$ объектов, в каждом из которых мы хотим что-то знать про много других. Без оптимизаций нам придётся сохранить \O{N^2} информации, но если мы научимся одни ответы вычислять через несколько других, то сможем соптимизировать это до \O{N \log N}. Для этого во время объединения ответов мы копируем не всю информацию, а выбираем самую большую по размеру структуру и копируем всю остальную информацию в неё. Тогда каждый элемент будет копироваться не больше \O{\log N} раз и получаем требуемую асимптотику.
\end{itemize}
