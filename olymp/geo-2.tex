\head{Геометрия: продолжение}
Мы продолжаем изучать вычислительную геометрии и сегодня перейдём к алгоритмам, работающим с ещё более сложными геометрическими объектами (многоугольниками и наборами точек). Для этих алгоритмов мы будем использовать уже написанные нами классы, при этом, для многоугольников создавать отдельного класса мы не будем, потому что алгоритмы достаточно объёмны, и использовать их в одной задаче вряд ли понадобится.

Единственное, что стоит сказать про многоугольники, это способ их хранения: набор точек в порядке их обхода (по часовой стрелке или против). При для $n$-угольника удобно хранить на одно точку больше: $p_0,\ p_1,\ \ldots,\ p_{n - 1},\ p_n = p_0$, чтобы все стороны многоугольника легко обходились одним циклом без дополнительных условий: $p_0 \to p_1 \to \ldots \to p_{n - 1} \to p_n$.


\subhead{Площадь многоугольника}
Первым алгоритмом мог бы быть поиск периметра многоугольника, но это совсем тривиальный алгоритм, ведь достаточно сложить длины сторон, а это мы уже умеем делать (например, через длину вектора). Поэтому первым нашим алгоритмом будет поиск площади многоугольника. Хоть для многоугольников и нет такой простой формулы, как, например, для треугольника или прямоугольника, но всё равно площадь многоугольника можно вычислить, если разбить его на отдельные фигуры.

\textbf{\term{Метод трапеций}.} Оказывается, что многоугольник очень хорошо разбивается на трапеции, площадь которых уже легко считается. Пусть мы рассматриваем очередную сторону из точки $a = p_i$ в точку $b = p_{i + 1}$, тогда рассмотрим трапецию с точками $a$, $b$, $c\pmath{b_x}{0}$, $d\pmath{a_x}{0}$ и вычислим её площадь $\Delta S = \frac{1}{2} \cdot (b_y + a_y) \cdot (b_x - a_x)$. А если мы посчитаем суммы всех таких площадей, то как раз получится площадь исходного многоугольника (потому что часть из этих слагаемых положительна, а часть отрицательна, и как раз всё получается хорошо).

Формула, конечно, приятная, но вот ее верность не очевидна. Чтобы проверить верность формулы, будем доказывать, что каждая точка\footnote{Так как площадь точки 0, то, возможно, правильнее разбивать на маленькие прямоугольники. Но, понятно, что поскольку в программах точность координат у точек конечная, то такое разбиение точно найдётся. Поэтому, для дальнейшего удобства, будем использовать точки.} посчитана правильное количество раз (точки внутри многоугольника должны быть посчитаны ровно один раз, вне — 0 раз, а на границе — без разницы, потому что суммарная площадь границы всё равно 0).

А теперь рассмотрим какую-нибудь точку $r\pmath{r_x}{r_y}$, не лежащую на границе (для определённости $r_y > 0$, случай $r_y = 0$ понятен, а $r_y < 0$ аналогичен текущему), построим точку $r'\pmath{r_x}{0}$, проведём прямую $rr'$. Далее рассмотрим все стороны, которые пересекают $rr'$ (то есть потенциально влияют на учёт точки $r$). Во-первых, не будем учитывать вертикальные стороны (которые лежат на $rr'$), ведь для них $\Delta S = 0$ и они ни на что не влияют. А во-вторых понятно, что нужны только стороны. пересекающие $rr'$ выше $r$, ведь только они учитывают нашу точку $r$.

А теперь всё совсем просто, ведь если точка лежит вне многоугольника, то должно остаться чётное количество прямых, ведь над $r$ должно быть какое-то целое количество частей многоугольника, и у каждой из них должна быть верхняя и нижняя сторона. Но раз мы в нашем алгоритме по очереди обходим все стороны, то по одной стороне мы должны пройти слева направо, а по другой справа налево, а следовательно наша точка $r$ посчитается 0 раз. А если же точка лежит внутри многоугольника, то на пары разобьются все стороны, кроме самой верхней (или самой нижней), а значит точка $r$ почитается ровно 1 раз. И, очевидно, что все точки внутри будут посчитаны с одинаковым знаком (потому что разные части верхней границы мы не могли пройти в разные стороны, ведь обходим вершины последовательно).

\textbf{\term{Метод треугольников}.} Но рассмотренный способ не единственный и существует другой. Произвольно выберем точку $O$ и для каждой стороны из точки $a = p_i$ в точку $b = p_{i + 1}$ посчитаем \term{ориентированную площадь} треугольника $Oab$: $\Delta S = \frac{1}{2} \cdot (\v{Oa} \wedge \v{Ob})$. И в конце нужно просуммировать все эти частичные суммы.

Снова алгоритм не сложный, но не очевидный, поэтому будем его доказывать (благо доказательство почти такое же). Для каждой точки $r$ будем доказывать, что она посчитана нужное число раз. Точка же считается только когда сторона пересекает луч $Or$ за точкой $r$, при этом стороны, лежащие на луче, мы учитывать не будем. Если $r$ лежит вне многоугольника, то мы имеем чётное количество пересечений. разбиваемые на пары, а следовательно $r$ посчитается 0 раз. Если же $r$ лежит внутри, то получим нечётное количество пересечений, все из которых, кроме одного, разобьются на пары и самоуничтожатся. А оставшаяся одна сторона посчитает нашу точку $r$ ровно один раз, причём все точки внутри многоугольника будут посчитаны с одним знаком, ведь мы обходим стороны последовательно.

Теперь мы знаем два метода вычисления площади многоугольников, оба из которых работают за \O{n}. При этом, если у нас точки целочисленные, то площадь будет \term{полуцелым} числом (так называются числа вида $\frac{m}{2}$, где $m \in \set{Z}$), поэтому лучше вынести коэффициент $\frac{1}{2}$, и сначала посчитать удвоенную площадь, а в конце только один раз поделить её на 2 (так погрешность будет меньше). Ещё стоит добавить, что второй способ можно модифицировать, если у нас будут более сложные фигуры, у которых стороны не прямые, а, например, дуги окружностей (формула поменяется, но общий алгоритм останется прежним).


\subhead{Принадлежность точки многоугольнику}
Теперь пусть нам дан многоугольник $p$ и требуется проверить, где лежит данная точка $r$: внутри, снаружи или на границе многоугольника. Но определить принадлежность точки границе легко (просто переберём все стороны и проверим принадлежность точки отрезку), поэтому нам нужно научиться разделять точку внутри и снаружи многоугольника.

\textbf{Ray shooting.} Этот метод очень похож на то, что мы делали раньше, когда искали площадь многоугольника. Выпустим какой-нибудь луч из точки $r$ и будем считать количество сторон, пересекающих луч. Если оно оказалось нечетным, то точка внутри многоугольника, а если чётным — то снаружи. Единственная проблема — случай, когда луч прошёл через вершину многоугольника, в таком случае можно действовать несколькими способами:

\begin{enumerate}
    \item Выпускать новый луч, пока эта проблема не устранится. Такой способ достаточно весёлый и действенный, причём если генерировать луч не случайным образом, то при целочисленных точках такая проблема гарантирована не возникнет, например, если все точки в задаче из диапазона $[-C; C]$, то можно выпустить луч в точку \p{3C+1}{3C+2} и всё будет хорошо из соображений теории чисел.
    \item Если предыдущий способ показался каким-то ненадёжным, то давайте немного модифицируем алгоритм. Выпустим луч вправо (чтобы он прошёл через \p{r_x+1}{r_y}) и будем засчитывать пересечение только если один из концов стороны строго ниже луча, а другой конец — выше или лежит на луче. Утверждается, что такой способ даёт верные ответы, что читатель может попробовать доказать самостоятельно.
\end{enumerate}

\textbf{Winding number.} Будем суммировать углы поворота нашей точки, для этого проведём $\v{a} = \v{rp_i}$ и $\v{b} = \v{rp_{i + 1}}$, и к текущей сумме углов добавим $\Delta \theta = \widehat{a;b}$ (это мы как раз уже умеем считать). Если в итоге сумма $\theta$ оказалось равна 0, то точка лежит вне многоугольника, а если же $\theta = \pm 2\pi$, то точка лежит внутри многоугольника. Видно, что этот способ очень простой, главное в конце учесть погрешности, которые могли накопиться при вычислении большого количества углов.

Оба представленных выше алгоритма работают за \O{n}, причём проверка принадлежности точки границе многоугольника делается с такой же сложностью, а значит и вся классификация выполняется за линейное время.

\textbf{Выпуклый случай.} Но не всё так просто, как могло бы показаться. Оказывается, что для выпуклых многоугольников существует более быстрый алгоритм, основанный на бинарном поиске.

Найдём самые левые точки и выберем из них самую нижнюю, назовём её $O$. Теперь заметим, что из-за выпуклости остальные точки упорядочены по углу относительно точки $O$, причём эти углу лежат в диапазоне $(\frac{\pi}{2}; \frac{\pi}{2}]$ радиан. Поэтому если точка $r$ не попала в этот диапазон, то она точно не лежит внутри многоугольника, а если попала, то можно сделать бинарный поиск, который найдёт две такие вершины $a$ и $b$, что луч $Or$ лежит между лучами $Oa$ и $Ob$. А после этого остаётся лишь проверить, лежит ли точка $r$ внутри треугольника $Oab$, что делается хоть через CW/CCW, хоть через способы, изученные чуть раньше.

Сложность такого алгоритма составляет всего \O{\log n} на один запрос, но при этом требуется \O{n} на предобработку по поиску точки $O$.


\subhead{Выпуклая оболочка}
Последняя задача, которую мы сегодня изучим, берёт множество точек и строит по ним \term{выпуклую оболочку} — выпуклый многоугольник минимальной площади, в котором содержатся все исходные точки. Оба алгоритма, которые мы пройдём, будут основываться на том факте, что у выпуклых многоугольников для троек подряд идущих вершин выполняется или всегда CW, или всегда CCW, в зависимости от обхода многоугольника по/против часовой стрелки.

\textbf{Алгоритм Грэхема.} Выберем самую правую точку из самых нижних и назовём её опорной $r$. Затем отсортируем все остальные точки относительно опорной: сначала будут идти точки с меньшим углом, а если у каких-то точек угол одинаковый, то раньше будет идти та точка, которая ближе к опорной.

Теперь заметим, что опорная точка $r$, а также самая маленькая $p_0$ и самая большая $p_{n-2}$ точно должны лежать в выпуклой оболочке. Поэтому добавим их в стек $s$ в порядке $p_{n-2}$, $r$, $p_0$. А далее для всех вершин $p_2,\ p_3,\ \ldots,\ p_{n-2}$ будем действовать следующим образом: если $s_{|s|-1}$, $s_{|s|}$ (последние точки стека) и $p_i$ образуют CCW, то добавляем $p_i$ в $s$ и переходим к следующему $i$; иначе у нас неправильный поворот, поэтому удаляем последнюю вершину из $s$.

Правильность алгоритма, вроде бы, очевидна, ведь самую дальнюю точку по углу нам точно придётся брать и при этом они должны образовать выпуклую фигуру, чего мы и добились проверкой на CCW. Также понятно, что опорная точка тоже должна лежать в выпуклой оболочке, ведь оно является крайней и не может быть включена в оболочку за счёт других рёбер.

\textbf{Алгоритм Эндрю.} Найдём две опорных точки: $a$ — самая нижняя из левых и $b$ — самая верхняя из правых точек. Теперь разобьём все точки на два множества (верхнее и нижнее) в зависимости от расположения с прямой $ab$, при этом точки $a$ и $b$ попадают в оба множества, а точки на отрезке $ab$ можно никуда не добавлять, потому что они точно не будут в выпуклой оболочке. Для каждого множества будем отдельно строить выпуклые оболочки, причём точки $a$ и $b$ точно лежат в обеих.

Для верхнего множества в стек $u$ добавим $a$, аналогично сделаем для нижнего $d$. Теперь отсортируем все точки каждого множества, кроме $a$ сначала по координате $x$, а потом по $y$. Далее пойдём по верхнему множеству и пока $|u| \geq 2$ и при этом поворот точек $u_{|u| - 1}$, $u_{|u|}$, $p_i$ неправильный (не CW) будем удалять верхнюю вершину из стека $u$, а после всех удалений добавим $p_i$ на стек. Аналогично сделаем в нижнем множестве, только вместо CW поворота будем проверять CCW. 

После этого у нас в обоих будут какие-то последовательности вершин $u = a,\ u_2,\ u_3,\ \ldots,\ u_{|u| - 1},\ b$ и $d = a,\ d_2,\ d_3,\ \ldots,\ d_{|d| - 1},\ b$, которые нужно объединить в итоговую выпуклую оболочку $h = a,\ u_2,\ u_3,\ \ldots,\ u_{|u| - 1},\ b,\ d_{|d| - 1}, \ d_{|d| - 2},\ \ldots,\ d_2$, что делается за линейное от размера оболочки время.

Правильность же алгоритма следует из правильности Алгоритма Грэхема, ведь если выбрать опорной точку \p{0}{-\infty}, то сортировка по координате эквивалентна сортировке по углу.

Сложность у обоих алгоритмов составляет \O{n \log n}, поскольку требуется сортировка, а после алгоритмы линейные действует за линейное время.

Стоит заметить, что можно доказать оптимальность такой временной сложности для алгоритмов, не зависящих от размеров выходных данных. В самом деле, пусть нам дали $n$ точек, лежащих на одной параболе: $\pmath{x_1}{x_1^2},\ \pmath{x_2}{x_2^2},\ \ldots,\ \pmath{x_n}{x_n^2}$. Тогда все эти точки должны оказаться в выпуклой оболочке, а значит, алгоритм построения выпуклой оболочки должен будет отсортировать все точки по координате $x$ а после этого соединить их последовательно. Но а сортировка, как мы доказывали раньше, в общем случаем делается за \O{n \log n}.

Но всё же, если использовать алгоритмы сортировки, не основанные на сравнениях (так, например, можно сделать с целыми числами), то можно будет строить выпуклую оболочку с той же временной сложностью, что и для алгоритма сортировки. К тому же, если алгоритм как-то зависит от количества $h$ вершин итоговой выпуклой оболочки, то его сложность в общем виде \O{n \log h}, но, при этом, может быть ещё улучшена за счёт алгоритмов сортировки.

Также стоит сказать, что существуют алгоритмы, работающие и для 3, 4, 5, $n$-мерных пространств, но мы их рассматривать не будем, ведь это не требуется в олимпиадной информатике.

