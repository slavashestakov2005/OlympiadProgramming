\head{Простые линейные алгоритмы}
Сегодня мы изучим несколько популярных линейных алгоритмов, которые могут пригодиться при решении более сложных задач.


\subhead{Правильная скобочная последовательность}
Первой задачей, которую мы разберём будет \term{правильная скобочная последовательность} (ПСП). Самое простое определение у ПСП — это такая последовательность скобок, которую можно получить из математического выражения, при удалении всех символов, кроме скобок. Но чуть более практичным является другое определение: пустая СП является правильной; ПСП обёрнутая в ещё одни скобки тоже является ПСП; если $A$ и $B$ являются ПСП, то и $AB$ — тоже ПСП.

Нам даётся строка $s$ длины $n$, нужно проверить, является ли она ПСП. Для начала разберём случай, когда у нас есть только один вид скобок (например, только круглые скобки).

Давайте поймём, что из-за того, что у нас вид скобок только один, то нам без разницы на то, какие именно скобки будут стоять друг с другом в парах, а главное — лишь способность скобок разбиться на пары. Поэтому придумаем критерий разбиваемости скобок на пары. Во-первых, понятно, что количество открывающих и закрывающих скобок должно быть равно. Во-вторых, и это чуть менее очевидно, если мы рассмотрели первые элемента строки $s_1,\ s_2,\ \ldots,\ s_i$, то у нас не может закрывающих скобок быть больше, чем открывающих. 

Теперь проверим, достаточно ли таких критериев. Понятно, что если наша строка является ПСП, то она отвечает обоим критериям и наш алгоритм скажет, что это действительно ПСП. Остаётся лишь проверить, обратное условие: предположим, что найдутся строки, которые не являются ПСП, но наш алгоритм скажет, что они ПСП. Тогда выберем из этих строк самую короткую, пусть это $t$. Мы точно знаем, что $t$ не пустая, поэтому в ней должна найтись закрывающая скобка (чтобы количество открывающих и закрывающих уравнялось). Среди этих скобок выберем самую первую, пусть она стоит на позиции $x$. Согласно нашему алгоритму среди символов $t_1,\ t_2,\ \ldots,\ t_x$ количество закрывающих не больше, чем количество открывающих. А следовательно $x \geq 2$, и мы можем удалить символы $t_{x - 1}$ и $t_x$ (это будут открывающая и закрывающая скобки соответственно), так мы сможем перейти к строке $t'$, в которой на 2 символа меньше.

Предположим, что $t'$ — ПСП, тогда и $t$ будет ПСП, ведь можно вставить пару скобок в любое место математического выражения; но изначально мы брали, что $t$ — не ПСП. Значит $t'$ должна быть не ПСП, при этом наш алгоритм должен был дать правильный ответ на этой строке. Но если алгоритм дал такой ответ, то должно было нарушиться одно из условий. Если нарушилось первое, то количество скобок в $t'$ разное, а значит и количество скобок в $t$ — тоже разное. а так нельзя, ведь наш алгоритм, по предположению, ошибся на строке $t$. Значит для строки $t'$ должно было нарушиться второе условие. Если оно нарушилось на коком-то из символов $1,\ 2,\ \ldots,\ x-2$, то на этом же символе оно нарушится и в строке $t$, а так нельзя. Значит второе условие нарушилось на символе $t'_y$, где $y > x - 2$, но тогда точно также условие нарушится и $t_{y + 2}$, ведь парные скобки никак не виляют на второе условие, а следовательно и так быть не может.

Так мы разобрали все варианты и пришли к противоречиям, а значит нет строк на которых наш алгоритм даёт не правильный ответ. Поэтому мы можем немного упростить эти два критерия, чтобы их было проще проверять: будем последовательно смотреть на символы $s$ и на каждом символе будем пересчитывать величину $b$ — количество открывающих скобок минус количество закрывающих (изначально $b=0$). И теперь первое условие превратится в то, что должно быть $b=0$ после просмотра всех символов, а второе условие — должно быть $b \geq 0$ после каждого очередного символа.

И раз у нас есть алгоритм для одного типа скобок, то мы теперь можем перейти к более общей задаче, где несколько типов скобок. Понятно, что для такой задачи должны выполняться все предыдущие условия (причём для каждого типа скобок отдельно). Но также, ещё нужно проверять, что у нас пары скобок одинакового типа.

Поэтому будем смотреть на строку $s$ слева направо и запоминать открывающие скобки, которые мы уже видели, в стек $v$. Если очередной символ — открывающая скобка, то добавим её в $v$. Если же наш символ — закрывающая скобка, то нужно проверить, что последняя скобка из $v$ парна нашей текущей скобки. Если не парна — то $s$ не ПСП, если парна — то нужно забыть эти обе скобки (удалить открывающую из $v$) и продолжить смотреть на строку. В конце не должно остаться не парных открывающих скобок, а значит $v$ должен быть пуст.

Понятно, что такой алгоритм верен, ведь наличие парной скобки в $v$ гарантирует, что $b \geq 0$, а также, что скобки действительно парные. Условие же для конца строки $b=0$ в нашем случае эквивалентно, что в конце $v$ пуст. Также понятно, что этот общий алгоритм справится и с частной задачей, когда тип скобок был только один.

И сложность обоих алгоритмов будет \O{n}, ведь для каждого символа нужно только изменение $b$ или $v$, а это элементарные операции и делаются они за \O{1}.


\subhead{Постфиксная запись}
Важным этапом в информатике было научиться вычислять математические операции с учётом скобок, приоритета и прочего. Одним из способов, которым удалось решить эту проблему, является \term{обратная польская запись} (ОПЗ). У ней есть ряд преимуществ, из-за которых выражения в ней очень легко считаются: во-первых, нет скобок, во-вторых, нет приоритета у операций. Алгоритм преобразования обычного выражения (записанного в \term{инфиксной нотации}) в ОПЗ мы рассматривать не будем\footnote{Если читатель заинтересовался, то может изучить этот алгоритм самостоятельно, прочитав, например, \href{https://ru.wikipedia.org/wiki/\%D0\%9E\%D0\%B1\%D1\%80\%D0\%B0\%D1\%82\%D0\%BD\%D0\%B0\%D1\%8F_\%D0\%BF\%D0\%BE\%D0\%BB\%D1\%8C\%D1\%81\%D0\%BA\%D0\%B0\%D1\%8F_\%D0\%B7\%D0\%B0\%D0\%BF\%D0\%B8\%D1\%81\%D1\%8C}{статью на Википедии}}, а лишь рассмотрим пример такого соответствия:
$$(1 - 2) \times 4 + 3 \to 1\ 2 - 4 \times 3 +$$

А теперь мы узнаем алгоритм вычисления выражений в ОПЗ и поймём, что такая запись действительно очень упрощает алгоритм. Для этого заведём стек $v$ и если нам встретилось число, то его нужно добавить в $v$. Если же очередной элемент ОПЗ — оператор $op$, то его нужно обработать: возьмём $a$ — верхний элемент стека, удалим его, возьмём $b$ — новый верхний элемент и удалим и его; и после этого в $v$ нужно добавить $b\ op\ a$. Если исходная ОПЗ корректна, то в конце этого алгоритма в $v$ будет одно число — результат вычисления выражения.

Теперь мы научились вычислять выражения, записанные в ОПЗ. Остаётся добавить, что, во-первых, сложность такого алгоритма \O{n}, где $n$ — длина входной строки с ОПЗ. Во-вторых, и это чуть менее очевидно, такой калькулятор можно развивать достаточно сильно, например, из него можно сделать язык программирования, если добавить новые операторы и научиться их обрабатывать (присваивание, сравнения, условия, циклы и т.д.), но этим мы заниматься не будем, так как это не относится к олимпиадному программированию\footnote{Читателю, который решится создать язык программирования на основе этого калькулятора, стоит знать, что это действительно возможно, так как автор книги сам так сделал язык программирования :)}.


\subhead{Элементы с максимальной разностью}
Теперь рассмотрим другую задачу: дан набор $a$ длины $n$, требуется найти такие индексы $i$ и $j$, что $i < j$ и при этом $a_j - a_i$ принимает максимальное значение.

Самый первый алгоритм, который можно придумать — перебрать за \O{n^2} все возможные пары и найти среди них наилучшую. Но понятно, что у нас сейчас тема линейные алгоритмы, а значит эту задачу можно решать быстрее.

А раз так, то давайте думать, как оптимизировать перебор. Мы хотим придумать линейный алгоритм, а это значит, что должно быть $n$ каких-то состояний, которые мы по очереди сможем перебирать, при этом из одного состояния мы должны переходить в следующее достаточно быстро. Во-первых, давайте определимся, что $n$ состояниями будет та часть набора, которую мы уже обработали. После этого нам нужно будет перейти к следующему состоянию, а значит придётся двигать правую границу. А раз так, то давайте на каждом шаге будем фиксировать правую границу и подбирать наилучший ответ.

Понятно, что для заданного $a_j$ наилучшем будет минимальное среди чисел $a_1,\ a_2,\ \ldots,\ a_{j - 1}$. Конечно, мы бы могли каждый раз заново вычислять минимальное значение среди всех этих чисел, но такой алгоритм не будет оптимальным, так как мы вновь будем перебирать все пары индексов. Поэтому нужно как-то воспользоваться ответом, который мы знали раньше. А на прошлом состоянии у нас было число $a_{j - 1}$ и набор $a_1,\ a_2,\ \ldots,\ a_{j - 2}$, в котором мы знали минимальный элемент (пусть $x$). Тогда видно, что для у нас в наборе стало на один элемент больше, а значит его минимум это $\min(x, a_{j - 1})$, что уже легко считается. Остаётся лишь как-то посчитать первое состояние для этого алгоритма, ведь его нельзя пересчитать через предыдущее. Поэтому при $j = 2$ минимальным числом нужно считать $a_1$, и текущим ответом $a_2 - a_1$.

Теперь ещё раз опишем этот алгоритм без лишних рассуждений. Будем хранить 3 числа: индекс текущего минимального значения ($i$) и индексы текущей оптимальной пары. Изначально считаем $i = 1$, а оптимальной парой — $(1, 2)$. Теперь для всех правых границ ($j$) из диапазона $[3; n]$ сначала сделаем $i = j - 1$, если $a_i > a_{j - 1}$ и после этого сравним текущей ответ (пара $(i, j)$) с предыдущим ответом, и если нужно, то обновим ответ на задачу. Так после всех шагов мы узнаем пару индексов с наибольшим значением $a_j - a_i$ (при $i < j$).

Понятно, что сложность такого алгоритма \O{n} — как раз линейная, чего мы и хотели добиться изначально.


\subhead{Отрезок с заданной суммой}
Теперь рассмотрим другую задачу про набор $a$ длины $n$. Здесь нам нужно будет найти такие два числа $l$ и $r$, что будет выполнено равенство $a_l + a_{l + 1} + \ldots + a_r = x$, где $x$ вводится пользователем и при этом $a_i \geq 0$.

Решение за \O{n^3} очевидно, для этого достаточно перебрать все пары индексов и для них посчитать сумму, но такое решение что-то совсем не оптимальное. Поэтому снова будем придумывать линейный алгоритм.

Будем пользоваться методом двух указателей: заведём два индекса $i$ и $j$, и будем для них проверять условие задачи, и если ответ до сих пор не найден, то будем двигать какой-нибудь из указателей, но только вправо. Поскольку оба указателя переберут не более $n$ значений, то мы получим линейную сложность.

Так вот, пусть мы получили указатели $i$ и $j$, а также знаем, что $a_i + a_{i + 1} + \ldots a_r = s$. Тогда нам нужно понять, какой из указателей стоит двигать. Первый, наиболее очевидный случай, когда $s = x$, то это значит, что мы уже нашли ответ на задачу и можем заканчивать поиск. Если же $s < x$, то это значит, что элементов ещё мало и нужно расширить диапазон, а значит добавим к $s$ число $a_{j + 1}$ и передвинем вправо $j$, так наш диапазон станет расширится на один элемент справа. И последний случай, когда $s > x$, то диапазон следует уменьшать, а значит нужно двигать $i$: сначала убавим $s$ на $a_i$, а потом увеличим $i$ на единицу, уменьшив диапазон на один элемент слева. И дополнительная проверка, которую нужно делать — что оба индекса ещё находятся в наборе, а если какой-то из них вылез за его пределы (сначала это будет $j$), то алгоритм нужно завершать, с ответом, что такой пары не существует.

Остаётся понять, почему такой алгоритм будет всегда давать верные ответы. Если алгоритм нашёл два индекса, то понятно, что такая пара действительно подходит. Поэтому проверим второй вариант: пусть у нас есть какой-то набор $a$, для которого ответами являются $L$ и $R$, но наш алгоритм эту пару не нашёл. Но раз алгоритм не нашёл ответа, то это значит, что наше $j$ прошло по всем элементам $a$, в частности по $R$, а вот $i$ могла когда-то быть $L$ (но не обязательно). Теперь рассмотрим два случая, если сначала наступил момент, когда $i = L$, то значит $j < R$, и тогда наш текущий отрезок $[i; j]$ лежит внутри ответа $[L; R]$, а значит $s \leq x$, и поэтому мы будем двигать правую границу и найдём ответ. Если же сначала наступило условие $j = R$, то значит $i < L$, но тогда отрезок с ответом $[L; R]$ лежит внутри текущего $[i; j]$, а следовательно $s \geq x$, и мы будем уменьшать сумму, двигая левую границу, и найдём ответ. То есть мы в любом случае найдём наш правильный отрезок, если он есть.

Как говорилось выше, сложность этого алгоритма \O{n}, потому что оба указателя совершают не более $n$ перемещений вправо.
