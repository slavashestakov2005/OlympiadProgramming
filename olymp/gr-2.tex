\head{Обходы графа}
Раз уж мы научились хранить графы в памяти компьютера, то можем и начать изучать алгоритмы на графах. Начнём мы с самых простых — обхода графа, потом научимся работать с компонентами связности, потом изучим ещё одну сортировку — топологическую (только это сортировка не обычного набора, а вершин графа). И в самом конце нас ждут компоненты сильной связности, мосты и точки сочленения.


\subhead{Поиск в ширину}
Первый алгоритм обхода это \term{BFS} (от \term{Breadth First Search} — обход графа в ширину. Этот алгоритм начинает обходить граф со стартовой вершины, потом посещает её соседей, потом соседей её соседей, и так далее, слой за слоем, пока соседи не закончатся. 

BFS основывается на очереди $q$ из вершин, которые ещё нужно посетить и списке $used$, хранящим информацию, какие вершины уже добавлялись в очередь (чтобы не обходить их два раза). Для этого сначала в $q$ добавляется стартовая вершина $s$ и она отмечается в $used$. Далее алгоритм шаг за шагом делает следующие операции:

\begin{enumerate}
    \item Берёт первую вершину $u$ из $q$ и удаляет её из $q$.
    \item Обходит все вершины $v$, связанные ребром с $u$. Если очередная вершина $v$ помечена в $used$, то пропускаем ей; если же в вершине $v$ мы ещё не бывали, то добавляем её в конец $q$ и отмечаем её в $used$.
    \item Если в $q$ ещё остались вершины, то операции нужно повторить.
\end{enumerate}

Благодаря списку $used$ каждая вершина добавляется в $q$ ровно один раз, а значит, на каждое ребро мы смотрим не более двух раз (потому что у ребра два конца), следовательно, сложность такого алгоритма будет \O{n + m}. Но, такая сложность доступна, только если граф представлен списком смежности, ведь только такое представление (из изученных) позволяет быстро получать всех соседей вершины.

Также понятно, что такой алгоритм применим на любом графе (ориентированном, взвешенном, не связном, не простом и т.д.) и при этом обходит все достижимые вершины, в частности, для неориентированных графов такой алгоритм посетит всю компоненту связности (для ориентированных тоже можно, если не учитывать направление рёбер, но это менее полезно).


\subhead{Поиск в глубину}
Второй алгоритм обхода это \term{DFS} (от \term{Depth First Search} — обход графа в глубину. Этот алгоритм начинает со стартовой вершины, потом посещает её первого соседа, потом первого соседа первого соседа, и так далее, пока остаются вершины, потом возвращается на несколько вершин, посещает второго соседа и так далее.

DFS основывается на рекурсии и списке $used$, хранящем информацию о том, какие вершины уже посещались. Для этого запускаем рекурсивный алгоритм, начиная со стартовой вершины $s$, и далее действуем шаг за шагом:

\begin{enumerate}
    \item Пусть мы запустились от вершины $u$, тогда её нужно отметить в $used$ как посещённую.
    \item Теперь обойдём все вершины $v$, в которые ведут рёбра из $u$. Если очередная вершина $v$ уже отмечена в $used$, то пропускаем эту вершины; иначе запускаем рекурсивный алгоритм от этой вершины $v$.
\end{enumerate}

Благодаря списку $used$ обход от каждой вершины запускается ровно один раз, а значит на каждое ребро мы смотрим не более двух раз (потому что у ребра два конца), и итоговая сложность алгоритма будет \O{n + m}. При этом DFS, также как и BFS, требует быстро получать соседей очередной вершины, а значит такая сложность достигается только на списках смежности.

При этом этот обход работает на любом графе и, как и предыдущий, посещает все достижимые вершины, а значит для неориентированных графов он посетит всю компоненту связности (можно искать их и в ориентированных графах, если не учитывать направление рёбер, но это мало полезно).


\subhead{Компоненты связности}
Как мы заметили, оба обхода графа (в ширину и в глубину) из заданной вершины $s$ посещают всю компоненту связности. А значит их можно модифицировать, чтобы найти все компоненты связности (и их свойства).

Запустим цикл, перебирающий все вершины. Если очередная вершина $s$ уже посещалась обходом, то пропускаем её; иначе запускаем какой-нибудь обход от этой вершины $s$. При этом можно сделать три (или больше) полезных модификации алгоритма:

\begin{enumerate}
    \item Считать количество запусков обхода, это и будет количеством компонент связности.
    \item Если во время каждого обхода считать количество посещаемых вершин, то получим размер компонент связности.
    \item С помощью $used$ можно определить к какой компоненте связности относится какая вершина. Для этого при первом запуске обхода посещаемые вершины в $used$ помечаем числом $1$, при втором обходе — числом $2$, и так далее (при этом непосещённые вершины отмечены, например, как $0$).
\end{enumerate}


\subhead{Топологическая сортировка}
Пусть у нас есть ациклический (без циклов) ориентированный граф, в котором нужно упорядочить вершины так, чтобы рёбра шли только слева направо (представим, что все вершины записаны в одну строчку). Для этого мы можем использовать уже изученные нами обходы графа (следовательно граф должен быть представлен как список смежности), которые сформируют список вершин $ts$ в порядке топологической сортировке. 

\textbf{Алгоритм Кана}, он же модификация BFS и основывается на очереди $q$. Сначала посчитаем для каждой вершины $deg\_in_i$ — входящую степень вершины $i$ и все вершины с $deg\_in_i = 0$ добавим в очередь $q$. Далее будем действовать следующим образом:

\begin{enumerate}
    \item Берём первую вершину $u$ из $q$ и удаляет её из $q$. Добавляем $u$ в список $ts$.
    \item Проходим по всем рёбрам $(u, v)$ (из вершины $u$ в вершину $v$). Уменьшаем входящую степень $deg\_in_v$ на 1 и если оказалось, что $deg\_in_v = 0$, то добавим $v$ в $q$.
    \item Повторяем эти операции, пока в $q$ остаются вершины.
\end{enumerate}

Теперь осознаем, почему этот алгоритм корректен. Понятно, что если у вершины $deg\_in_i = 0$, то в вершину $i$ не входят рёбра, а значит ей вполне можно поставить самой первой из всех оставшихся (если какие-то рёбра входили в $i$, то их начала уже были добавлены в $ts$, а значит всё на этой вершине правильно). Остаётся понять, что вершина с нулевой входящей степенью всегда должна быть: понятно, что такая вершина должна быть в начале, ведь иначе нет вершины, которая бы стала первой; также понятно, что это должно выполняться на каждом шаге, ведь мы удаляем вершины со всеми выходящими рёбрами, а значит остаётся только подграф, который тоже должен топологически сортироваться (ведь иначе и весь граф не отсортируется). То есть мы выяснили, что наш алгоритм корректен.

Сложность у этого алгоритма такая же \O{n + m}, как и предыдущих, ведь он добавляет каждую вершину в $q$ ровно один раз, а значит и на каждое ребро смотрит только один раз (т.к. граф ориентирован, то мы смотрим только с одной стороны, откуда ребро выходит).

\textbf{Алгоритм Тарьяна}, он же модификация DFS. Единственная модификация заключается в том, что в конце рекурсивной функции для вершины $u$ нужно будет добавить $u$ в конец $ts$. А когда все компоненты связности будут обработаны, то нужно будет развернуть $ts$.

Понятно, почему такой алгоритм работает, ведь когда мы заканчиваем рекурсивную функцию для вершины $u$, то это значит, что мы обработали уже все вершины, достижимые из $u$ и добавили их в $ts$, а значит после добавления вершины $u$ в $ts$ получим, что все рёбра из $u$ идут влево, поэтому в конце мы и разворачиваем $ts$.

Также понятно, что сложность у этого алгоритма \O{n + m} такая же, как и у DFS, ведь их разница только в формировании списка $ts$, что делается быстро за \O{n}.


\subhead{Компоненты сильной связности}
Пусть нам дан ориентированный граф, в котором требуется найти компоненты сильной связности (КСС, или SCC от \term{Strongly Connected Component}). Оказывается, что для решения такой задачи достаточно всего лишь модифицировать DFS.

\textbf{Алгоритм Косараджу}, основанный на двух DFS:

\begin{enumerate}
    \item Запустим обычный DFS, который запишет вершины в порядке выхода алгоритма из них (как $ts$ в Алгоритме Тарьяна для топологической сортировки), назовём этот список $tout$.
    \item Теперь будем рассматривать транспонированный граф (у него все рёбра развёрнуты относительно исходного графа).
    \item Будем запускать второй DFS от вершин в порядке уменьшения $tout$ для них. Все вершины, которые посещаются одним таким обходом являются одной SCC (посещается вся компонента и при этом без других вершин).
\end{enumerate}

Алгоритм выглядит понятным, но вот его корректность не очевидна, поэтому будем её доказывать. Во-первых нужно понять, что в обоих графах (исходном и транспонированном) SCC одинаковые (в самом деле, пусть $u$ и $v$ лежат в одной SCC в исходном графе, тогда есть какие-то пути $a: u \to v$ и $b: v \to u$, но после транспонирования они превратятся в $a^T: v \to u$ и $b^T: u \to v$, а значит $u$ и $v$ снова будут лежать в одной SCC; аналогично вершины разных SCC попали в разные SCC).

Для этого рассмотрим две компоненты сильной связности $C_1$ и $C_2$, между которыми есть путь из $C_1$ в $C_2$ (если бы при этом было путь из $C_2$ в $C_1$, то компоненты бы объединились в одну; если же между компонентами нет пути, то алгоритм, очевидно, работает). Рассмотрим вершину $u$, которая является первой из посещённых в $C_1$ и $C_2$ первым DFS.

Пусть $u$ лежит в $C_1$, тогда после этого он в каком-то порядке посетил остальные вершины из $C_1$ и из $C_2$ и потом вышел из них. Следовательно алгоритм сначала вышел из всех вершин $C_2$ и только потом вернулся в $u$ и вышел из неё. Но тогда запуск второго DFS сначала произойдёт из $u$, и попасть в $C_2$ мы не сможет (ведь второй DFS запускается на транспонированном графе), то есть в таком случае наш алгоритм работает корректно.

Иначе $u$ лежит в $C_2$. тогда сначала посетится вся $C_2$ и, возможно, какие-то ещё вершины, но в $C_1$ мы попасть не сможем, ведь туда нет пути. Следовательно мы сначала выйдем из $C_2$ и только потом зайдём и выйдем в $C_1$. То есть также, как и в предыдущий раз, второй DFS сначала запустится в $C_1$ и только потом из $C_2$, а значит и в таком случае всё сработает.

Таким образом мы доказали корректность алгоритма, его сложность понятна, ведь это всего лишь два DFS и транспонирование графа, а такие операции делаются суммарно за \O{n + m}.

\textbf{Алгоритм Тарьяна}, для него хватает одного DFS. Дополнительно нам понадобится в ходе алгоритма поддерживать $tin_i$ — время входа DFS'а в вершину $i$, $fup_i$ — минимальное время ($tin_u$), в которое можно попасть, выйдя из вершины $i$, и $processed_i$ — обозначающая, нашлась ли для $i$ SCC. Ещё мы будем запоминать в стек $s$ текущие вершины, которые ещё не попали ни в одну SCC. Изначально считаем все $tin_i = fup_i = -1$, $processed_i = false$, $s$ — пуста.

\begin{enumerate}
    \item В начале обхода вершины $u$ нужно: добавить $u$ в $s$, отметить её, как вычисляющуюся $processed_u = true$ и присвоить в $tin_u = fup_u$ текущее значение таймера (и увеличить таймер на 1).
    \item Перебираем все рёбра $u \to v$. Если очередную вершину $v$ мы ещё не посещали ($tin_v = -1$), то для неё нужно запустить DFS. После этого, если $processed_v = true$, то следует обновить $fup_u = \min(fup_u, fup_v)$.
    \item Если после обработки всех рёбер $u \to v$ значение $fup_u$ не обновилось ($fup_u = tin_u$), то это значит, что текущая вершина является началом SCC. Поэтому будем снимать вершины $x$ со стека, отмечать их как обработанные ($processed_x = false$) и добавлять к текущей SCC. Если же оказалось, что $x = u$, то SCC закончилась и можно выходить из функции.
\end{enumerate}

Понятно, почему такой алгоритм работает, ведь SCC должны образовывать циклы, а цикл обязательно заканчивается где-то в вершине $a$ среди обрабатывающихся вершин. А раз так, то дойдя до $a$ мы начнём постепенно возвращаться к предыдущим вершинам $b$ цикла и по сути делать для них обновление $fup_b = \min(fup_b, tin_a)$, в вершине $a$ такое обновление ничего не даст, поэтому мы найдём начало цикла (если же из $a$ есть ещё какие-то рёбра в более ранние вершины, то после их посещения $fup_a$ уменьшится и мы цикл на этом шаге не найдём, ведь его начало было где-то ещё раньше).

Также понятна временная сложность алгоритма \O{n + m}, потому что мы всего лишь модифицировали DFS, при этом все новые операции выполняются за постоянное время.


\subhead{Мосты и точки сочленения}
Пусть нам дан неориентированный граф, и в нём требуется найти \term{мосты} — рёбра, после удаления которых число компонент связности увеличивается и \term{точки сочленения} — вершины, после удаления которых компонент связности становится больше. Как это ни удивительно, но и для этого нам достаточно всего лишь модифицировать DFS.

Но перед быстрым алгоритмом заметим, что относительно легко можно придумать медленный алгоритм, который сначала запускает DFS, считающий компоненты связности, а потом по очереди убирает все вершины и рёбра и проверяет, сколько компонент стало. Но такой алгоритм действительно долгий, со сложностью \O{(n + m)^2}, а нам хотелось бы быстрее.

Давайте снова будем вычислять $tin_i$ — время входа DFS'а в вершину $i$, $fup_i$ — минимальное время ($tin_u$), в которое можно попасть, выйдя из вершины $i$. Изначально считаем все $tin_i = fup_i = -1$. После этого запускаем обход от вершины $root$.

\begin{enumerate}
    \item Пусть обход перешёл в вершину $u$ из вершины $p$ (для $root$ считаем, что $p = -1$). И присваиваем $tin_u = fup_u$ текущее значение таймера (и увеличить таймер на 1).
     \item Перебираем все рёбра $(u, v)$. Если $v = p$, то такое ребро нужно пропустить. Если очередную вершину $v$ мы уже посещали ($tin_v > -1$), то нужно обновить $fup_u = \min(fup_u, tin_v)$.
     \item Если же $v$ мы ещё не посещалась, то нужно запустить для неё DFS (передав $u$ как родительскую вершину) и обновить $fup_u = \min (fup_u, fup_v)$. Если $u = root$, то нужно запомнить, что запускался DFS, иначе если $fup_v \geq tin_u$, то из $v$ не нашёлся путь куда-то вверх, а значит $v$ — точка сочленения, а если $fup_v > tin_u$, то ребро $(u, v)$ является мостом.
     \item Если после обхода всех рёбер оказалось, что $u = root$ и мы запускали DFS больше одного раза, то посещённые поддеревья не связаны, а значит, $root$ — точка сочленения.
\end{enumerate}

Понятно, что такой алгоритм работает, ведь, $fup_i$ действительно подсчитывает наименьшее время, достижимое из $i$, а критерии моста $fup_v > tin_u$ и точки сочленения $fup_v \geq tin_u$ понятны, ведь это и обозначает, нашёлся ли путь в какую-то более раннюю вершину. Наличие отдельного критерия для $root$ тоже понятно, ведь корневая вершина никогда не попадает под обычное условие, так как время входа в неё минимальное.

Сложность этого алгоритма (как и всех предыдущих алгоритмов обхода) составляет \O{n + m}, что явно лучше нашего тривиального решения.
