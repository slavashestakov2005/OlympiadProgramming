\head{Остовные деревья}
Мы продолжаем изучать графы, и сегодня займёмся поиском \term{минимального остовного дерева} — остовного дерева в неориентированном графе с минимальным суммарным весом рёбер, и модификациями данной задачи.


\subhead{Минимальное остовное дерево}
На самом деле, раньше мы уже находили остовные деревья, когда совершали обходы графа (для DFS это дерева строится рекурсией, а для BFS дерево создаётся из рёбер, помещающих новые вершины в очередь). Поэтому если наш граф невзвешенный, то мы можем считать все веса рёбер равными 1, а значит любое остовное дерево будет являться минимальным, то есть мы уже частично умеем решать задачу. Но для взвешенных графов алгоритм не такой простой, поэтому перейдём к его изучению.

\textbf{Алгоритм Прима.} Это своего рода модификация алгоритмов обхода графа, потому что запустимся мы от одной вершины и рёбра будем добавлять последовательно (так, что всё время будем иметь дерево). Также нам понадобится знать, какие вершины уже в дереве (список $used$) и структура данных, позволяющая быстро выбирать минимальный элемент (множество / отображение или куча), назовём её $p$. И алгоритм выглядит так:

\begin{box-algo}
    \begin{enumerate}
        \item Произвольно выберем стартовую вершину $u$, пометим её в $used$ и добавим все рёбра $(u, v)$ в $p$, при этом $p$ должна уметь выдавать ребро с минимальным весом.
        \item Теперь пока структура $p$ не пуста будем брать из неё минимальное ребро $(u, v)$ и удалять его из $p$. Если так оказалось, что обе вершины ($u$ и $v$) уже в дереве (помечены как $used$), то ребро нужно пропустить. А иначе мы добавляем ребро $(u, v)$ в итоговое дерево, помечаем $v$ как $used$ ($u$ уже в дереве, потому что ребро оказалось в $p$) и добавляем в $p$ все рёбра $(v, t)$, где $t$ ещё не в дереве (не $used$), чтобы избежать зацикливания.
    \end{enumerate}
\end{box-algo}

Понятно, почему такой алгоритм работает, ведь из уже существующего минимального дерева какое-то ребро провести придётся и поэтому мы выбираем максимальное. А раз мы так делаем пока все доступные рёбра не получатся, то мы как раз получим минимальное остовное дерево текущей компоненты связности. Если же ещё есть другие КС, то будем запускать построение дерева от каких-то вершины из них и в итоге получим минимальный остовный лес.

Чем полезен такой алгоритм, так это возможностью смотреть не на все рёбра, а только на их часть, при выборе следующего ребра. Также для этого алгоритма граф должен быть представлен как список смежности, что тоже удобно, потому он применим в большом количестве других задач. 

Сложность такого алгоритма составляет \O{m \log m}, так обрабатывается $m$ рёбер и на каждое из них тратится \O{\log m}, ведь его нужно добавить в $p$ и достать из неё, а делается это не быстрее, чем за логарифм размера $p$. Также можно улучшить алгоритм до \O{m \log n}, если для каждой вершины хранить только минимальное ребро, ведущее в неё, но даже если считать, что в графе много рёбер, то $m = O(n^2)$ и $O(m \log m) = O(m \log n^2) = O(2m \log n) = O(m \log n)$, поэтому фактически улучшение может и не быть.

\textbf{Алгоритм Краскала.} Этот алгоритм сильно отличается от предыдущего, но схож тем, что на очередном шаге выбирает минимальное ребро. Для алгоритма нам понадобится список рёбер $e$, список $used$ посещённых вершин и структура $p$, позволяющая объединять множества и проверять элементы на принадлежность одному множеству (в простейшем случае можно использовать массив, но с DSU будет быстрее):

\begin{box-algo}
    \begin{enumerate}
        \item Для начала отсортируем $e$ по неубыванию веса, а в структуре $p$ размера $n$ сохраним, что все вершины пока принадлежат разным множествам (деревьям).
        \item Теперь будем перебирать все рёбра от меньшего веса к большему и если очередное ребро $(u, v)$ соединяет разные деревья, то это ребро нужно добавить к итоговому дереву и в $p$ объединить множества, представленные $u$ и $v$.
    \end{enumerate}
\end{box-algo}

Понятно, что и этот алгоритм тоже работает, ведь когда мы добавляем ребро $(u, v)$, то соединяем множество вершины $u$ с остальным деревом, и делаем мы это ребром с минимальным доступным весом. А значит и получаем в конце минимальное остовное дерево для связного графа и минимальный остовный лес для несвязного графа.

Сложность же алгоритма также составляет \O{m \log n}, ведь нам требуется $O(m \log m) = O(m \log n^2) = O(2m \log n) = O(m \log n)$ на сортировку рёбер и после этого мы выполняем \O{m} операций с $p$, которые в DSU можно реализовать за \O{\ac{n}}, то есть итого имеем $O(m \log n + m \ac{n}) = O(m \log n)$. Также важно, что этому алгоритму, в отличие от предыдущего, требуется список рёбер, что может быть несколько не удобно, но в зато этот алгоритм будет легко модифицировать, что мы дальше и увидим.


\subhead{Модификации минимального остова}
Искать только минимальное остовное дерево — это скучно, поэтому существуют другие схожие задачи, которые решаются теме же алгоритмами, что мы и прошли, после внесения небольших изменений. При этом нам будет проще вносить изменения в алгоритм Краскала, но некоторые задачи также решаемы и с помощью алгоритма Прима. Рассмотрением этих задач мы и займёмся.

\textbf{Максимальное остовное дерево.} В общем-то понятно, что здесь нужно сделать: раз у нас вместо минимума нужно найти максимум, то достаточно поменять правило сортировки на противоположное. То есть, для алгоритма Прима мы будем выбирать ребро с максимальным весом, а для алгоритма Краскала будем идти от рёбер с большим весом к рёбрам с меньшим весом. Но можно поступить более олимпиадно и поменять все веса $w \to -w$ и использовать уже их в обычных алгоритмах :)

\textbf{Минимальное достроение.} Пусть у нас в графе уже выбраны какие-то рёбра и нам нужно ещё выбрать какие-то рёбра так, чтобы суммарный вес был минимальным и количество компонент связности было таким же, как и в исходном графе.

Решить эту задачу также не сложно с помощью алгоритма Краскала. Для этого, перед запуском основного алгоритма, добавим все обязательные рёбра к результату и отметим в $p$, что какие-то множества соединены ребром. А после этого сделаем обычный запуск алгоритма Краскала.

\textbf{Лес из заданного числа компонент связности.} Пусть нам требуется найти минимальный остовный лес, но при этом он должен состоять из $k$ компонент связности (где $k$ не меньше, чем количество исходных КС).

Это тоже достаточно простая задача, ведь алгоритм Краскала на каждом шаге действует жадно, поэтому его достаточно будет прервать, когда останется $k$ компонент связности. Определить же это можно посчитав количество добавленных рёбер, их должно быть $m' = n - k$, ведь в каждой КС рёбер $m'_i = n_i - 1$ (так как это деревья), а всего $n = \sum\limits_{i = 1}^{k} n_i$, а значит $m' = \sum\limits_{i = 1}^{k} m_i = \sum\limits_{i = 1}^{k} (n_i - 1) = \sum\limits_{i = 1}^{k} n_i - k = n - k$. Такую же формулу можно получить, если учесть, что изначально мы имеем $n$ КС, а должны сделать $k$ КС, при этом каждое проводимое ребро объединяет две КС, а значит $m' = n - k$.

\textbf{Минимакс и максимин.} Минимаксом называет поиск пути между вершинами $i$ и $j$ такой, что вес этого пути минимален. При этом весом пути называется максимальной вес ребра, которые встречается на этом пути. Аналогично определяется максимин, там нужно максимизировать минимальный вес ребра на пути.

Если подумать, то оказывается, что искомый путь будет лежать в минимальном остовном дереве. В самом деле, при построении минимального остовного дерева мы на каждом шаге выбираем минимальное ребро, а значит и на пути между $i$ и $j$ добавляется ребро с минимальным возможным весом, а следовательно максимальный вес среди них действительно минимально возможный.

Итоговым алгоритмом будет: сначала найти минимальное остовное дерево, а после этого запустить какой-нибудь обход графа и найти максимальное значение на пути между $i$ и $j$. Итоговая сложность будет такой же, как и у построения дерева, ведь его обход выполняется за линейное время (так как в дереве имеем $m = n - 1$, и алгоритмы обхода отработают за $O(n + m) = O(n + n - 1) = O(n)$).

\textbf{Второе лучшее остовное дерево.} В этой задаче требуется найти не минимальное остовное дерево, а второе по минимальности. Это задача уже не такая очевидная, и сложность у неё получится несколько больше.

Заметим, что второе по минимальности остовное дерево можно получить, если произвести всего одну замену в обычном минимальном остовном дереве (то есть одно ребро удалить и одно добавить). И понятно, почему это условие выполняется, ведь если мы производим замену, то от этого суммарный вес дерева только увеличивается, а если делать несколько таких замен, то вес увеличится ещё больше. Следовательно, второе лучшее дерево отличается от лучшего всего одной заменой.

А раз так, то сначала построим первое лучшее дерево, а потом будем по очереди запрещать использовать его рёбра и строить новые минимальные остовные деревья. Тогда нам потребуется \O{m \log n} на первоначальную сортировку, \O{m} на поиск лучшего остовного дерева и после этого мы будим закрывать \O{n} рёбер, тратя на каждое ещё один поиск лучшего остовного дерева за \O{m}. И итоговая сложность будет \O{nm}. Но стоит отметить, что можно ускорить алгоритм, если использовать DSU или LCA, но это уже остаётся на изучение читателю :)
