\head{Перебор и битовые множества}
Теперь научимся решать любую задачу по информатике! Да, да перебором можно решить любую задачу, правда это не всегда будет оптимально (всего-то придётся подождать несколько сотен лет, чтобы перебрать, например, $20! \approx 2.4 \cdot 10^{18}$ вариантов :) )


\subhead{Перебор перестановок}
Сначала разберём перебор, сложность которого будет \O{n! \cdot n}. Во-первых, стоит сказать, что $10! \approx 3.6 \cdot 10^6, 11! \approx 4 \cdot 10^7, 12! \approx 4.8 \cdot 10^8$. Поэтому ограничение на применение такого перебора $10 \dash 11$ элементов. Во-вторых, такой перебор нужно использовать. когда требуется перебрать все возможные перестановки элементов (потому что $n!$ — количество перестановок, а $n$ — их длина, и это как раз даёт сложность, написанную выше).

Самый простой способ - использовать встроенные функции \lcpp{prev_permutation} и \lcpp{next_permutation}. Для этого нужно создать какой-нибудь контейнер со всеми элементами, которые мы хотим переставлять. Далее можно перебирать все перестановки (использовать всё время одну и ту же функцию) и проверять, что такой перестановки ещё не было (сравнивать с начальной). Но можно делать такой перебор чуть проще — сначала отсортировать контейнер и получить первую перестановку, сделать с ней операции, потом делать \lcpp{next_permutation}, и пока он продолжает возвращать \lcpp{true} делать операции с очередной перестановкой.

Также можно и самостоятельно генерировать все перестановки. Для начала разберём случай, когда элементов — заданное количество (пусть 3). Тогда можно сделать 3 вложенных цикла, которые все будут перебирать значения от 1 до 3 и проверять, что тройка чисел является перестановкой (каждое число используется ровно по одному разу). Так у нас сгенерируются все перестановки, причём в лексикографическом порядке. 

Если же количество элементов не постоянное, то нужно использовать рекурсию. Создадим глобальный список, в котором будем хранить очередную перестановку. Наша рекурсивная функция будет принимать позицию, для которой оно будет генерировать все варианты (считаем в 0-нумерации, позиции $0 \leq i < n$). Если позиция уже большая ($n$), то это значит, что мы всю перестановку сгенерировали и её можно как-то обработать, например, вывести. Если позиция ещё в допустимом диапазоне, то будем перебирать для неё возможные варианты. Для каждого варианта проверим, что это число ещё не использовалось и запустим эту же функцию для следующий позиции. 

Единственным пунктом, который может быть не понятен в этом алгоритме — проверить, что число ещё не использовалось. Для этого есть несколько решений:

\begin{enumerate}
    \item Перебрать все уже поставленные числа и сравнить, получим сложность \O{n}.
    \item Сохранить все элементы, которые ещё можно использовать в \lcpp{set} и проверять наличие элементов в нём, сложность — \O{\log n}.
    \item В предыдущем способе перебирать не все допустимые числа, а лишь те, которые ещё не использовались.
    \item Создать список длины $n$, в котором помечать, использованы ли элементы. Сложность — \O{1}.
\end{enumerate}

Лучшим из этих способов является четвёртый, так как у первого получится сложность \O{n^n \cdot n}, у второго \O{n^n \cdot \log n}, у третьего — \O{n! \cdot n \log n}, у четвёртого — \O{n^n}. И при $n = 10$ четвёртый способ быстрее третьего примерно в 30 раз. Хотя пытаться выбрать самый быстрый способ в таком случаем достаточно странно, ведь всё равно получается много операций и работать будет только для маленьких $n$.


\subhead{Номер перестановки}
Следующая задачей на перестановки может быть такой: научиться сопоставлять номер перестановки в лексикографическом порядке и саму перестановку. Мы будем делать это за \O{n^2}, но можно и ускорить до \O{n \log n}, если использовать структуры данных (это остаётся читателю на реализацию). 

Сначала будем получать номер перестановки (в 0-нумерации), считая, что у нас перестановка $a$ длины $n$ ($a_0, a_1, \ldots, a_{n - 1}$). Понятно, что в 0-нумерации номер перестановки равен количеству перестановок, меньших данной, поэтому такие перестановки мы и посчитаем. Будем смотреть на элементы по порядку (от $a_0$ к $a_{n - 1}$). Если бы первый элемент был меньше $a_0$, то и вся перестановка была бы меньше нашей, значит мы точно нашли $a_0 \cdot (n - 1)!$ перестановок, которые меньше. Теперь нужно посчитать, сколько перестановок с первым числом $a_0$ меньше, чем наша. Посмотрим на второй символ: все перестановки, у которых он меньше, чем $a_1$ были бы точно меньше. Если $a_0 > a_1$, то таких перестановок ровно $a_1 \cdot (n - 2)!$, но при этом, если $a_0 < a_1$, то элемент $a_0$ уже запрещён, поэтому мы нашли только $(a_1 - 1) \cdot (n - 2)!$ перестановок, меньших нашей. Так мы будем продолжать для всех элементов перестановки, для $a_i$: умножать $(n - 1 - i)!$  на количество чисел, меньших, чем $a_i$, и при этом не использовавшихся среди $a_0, a_1, \ldots, a_{i - 1}$; и добавлять это произведение к ответу.

Теперь остаётся выполнить обратную задачу: по номеру перестановки ($x$, 0-нумерация) и количеству элементов ($n$) определить перестановку. Во-первых должно выполняться, что $x < n!$, ведь столько всего перестановок :). Если это выполняется, то снова будем определять элементы по порядку (от $a_0$ к $a_{n - 1}$). Определяем первый элемент, для этого посчитаем $b = \frac{x}{(n - 1)!}$ и $c = x \mod (n - 1)!$. Понятно, что $b$ — количество чисел, меньших $a_0$, а значит $a_0 = b$ (потому что оставшаяся часть $a_1, a_2, \ldots, a_{n - 1}$ даёт только $(n - 1)!$ вариантов, а значит максимальный вклад в итоговую сумму —  $(n - 1)! - 1$). Теперь мы знаем первый элемент, знаем. что $b \cdot (n - 1)!$ перестановок уже точно меньше нашей, поэтому смотрим на второй элемент, делаем $x = c$ и пытаемся найти $x$-ую перестановку. Снова считаем два числа $b = \frac{x}{(n - 2)!}$ и $c = x \mod (n - 2)!$ и говорим, что $a_1 = b$ если $a_0 > a_1$ и $a_1 = b + 1$ если $a_0 < a_1$ (так как $a_0$ нельзя использовать второй раз). Аналогично делаем так для каждого индекса $i$: считаем $b = \frac{x}{(n - 1 - i)!}$ и $c = x \mod (n - 1 - i)!$ и говорим, что $a_i = b + v$, где $v$ количество чисел среди $a_0, a_1, \ldots, a_{i - 1}$ меньших, чем $a_i$; также обновляем $x = c$.

А теперь, умея сопоставлять перестановку и её номер, мы можем сгенерировать все перестановки за \O{n! \cdot n^2} (просто перебрав все допустимые номера и сгенерировав для них перестановки).


\subhead{Перебор наборов из заданных элементов}
Теперь разберём перебор всех наборов, которые состоят из заданных элементов. Более конкретно: нам нужно сгенерировать все наборы $a$ длины $n$, состоящие из элементов набора $b$ длины $m$. При этом одни и те же элементы $b$ можно повторять сколько угодно раз (в том числе 0).

Во-первых, ясно, что всего таких наборов будет $m^n$, потому что на любую позицию можно независимо выбрать любой элемент, а значит и сложность будет \O{m^n}. Во-вторых, можно заметить, что мы занимались чем-то похожим, когда генерировали перестановки. Теперь же у нас нет ограничения, что элементы должны быть различны, поэтому старый алгоритм упростится: создадим глобальный контейнер для ответа и рекурсивную функцию с одним параметром - позицией. Если позиция ($i$) большая ($i \geq n$), то набор сгенерирован и можно его, например, вывести. Иначе мы переберём все $m$ вариантов для $a_i$ и рекурсивно сгенерируем оставшуюся часть набора.


\subhead{Перебор подмножеств}
Ещё одно полезное применение перебора — перебор подмножеств. Подмножеством набора $a$ длины $n$ называется множество $b$ длины $m$, если можно получить $b$ из $a$ путём вычёркивания элементов (в том числе разрешено вычеркивать 0 элементов или все).

Можно свести данную задачу к предыдущей, если считать, что у нас в $b$ будет два элемента: $b = \{\text{«берём»}, \text{«не берём»}\}$. И сложность перебора будет \O{2^n}. Заметим, что такой перебор быстрее предыдущего, так как $2^{24} \approx 1.7 \cdot 10^7$ и $2^{27} \approx 1.3 \cdot 10^8$, и можно решить задачу за отведённое время при $n \approx 25$.

Но чем особенна данная задача — в компьютере используется двоичная система счисления, поэтому данный алгоритм можно реализовать с помощью битовых операций. А именно: переберём все числа из диапазона $[0; 2^n)$ (если кто-то забыл, то $2^n = 1 << n$). Посмотрим на запись каждого числа в двоичной системе счисления (если в записи меньше, чем $n$ знаков, то допишем слева не значащие нули) и если $i$-ый бит равен $1$, то мы берём число $a_i$ в набор, иначе — нет. Остаётся лишь научиться понимать, чему равен $i$-ый бит: для этого можно использовать побитовое И с числом $2^i = 1 << i$.

Такое использование двоичной системы счисления может навести на мысль, что с помощью чисел можно представлять множества, это действительно так и сейчас мы это изучим, и описание выше станет понятнее.


\subhead{Битовые множества}
Битовые множества хранят данные таким образом: возьмём все элементы (назовём их $x_i$, $0 \leq i < n$), которые нужно будет хранить в множестве, и сопоставим им числа $[0; n)$ (пусть $x_i \to i$). Далее возьмём достаточно большое число (в котором хотя бы $n$ битов), и если число в множестве есть, то поставим на соответствующую позицию 1, иначе — 0.

Теперь, с такими числами можно делать побитовые операции, и они будут соответствовать операциям с множествами:

\starttable
\begin{tabular}{|c|c|c|}
\hline
Название & Математическая запись & Побитовая запись \\
\hline
Дополнение & $\overline{A}$ & \lcpp{~A} \\
Пересечение & $A \cap B$ & \lcpp{A & B} \\
Объединение & $A \cup B$ & \lcpp{A | B} \\
Разность & $A \setminus B$ & \lcpp{A & ~B} \\
Симметрическая разность & $A \bigtriangleup B$ & \lcpp{A ^ B} \\
Одно число ($x_i$) & $\{ x_i \}$ & \lcpp{1 << i} \\
\hline
\end{tabular}
\endtable

Но в C++ уже есть встроенная структура \lcpp{bitset}, которая представляет битовые множества. Приведём пример работы с ними:

\cpp{com-3}{9}
