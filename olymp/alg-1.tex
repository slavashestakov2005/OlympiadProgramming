\head{Алгебра, часть 1}
Знакомство с олимпиадным программированием мы начнём с алгебры и теории чисел. Вообще, так называет раздел математики, но некоторые функции для чисел можно хорошо вычислять с помощью компьютера. Именно такие функции мы и изучим в этом блоке после того, как пройдём некоторые другие простые алгоритмы.


\subhead{Извлечение корня и бинарное возведение в степень}
Как всем известно, решением уравнения $x^2 = a$ являются $x = \pm \sqrt{a}$, при $a \geq 0$. И все знают, что есть встроенная функция, которая называется \lcpp{sqrt} и извлекает квадратный корень. Но у этой функции есть проблемы — она не совсем точная, а нам иногда хочется округлять значение корня до целого числа. Поэтому мы напишем функцию, которая будет приближать значение корня двумя целыми числами:

\cpp{alg-1}{6}

Извлекать корень мы научились, теперь хорошо бы и научиться возводить в степень. Для этого снова есть встроенная функция \lcpp{pow}, но у неё такой же недостаток, как и у \lcpp{sqrt} — погрешности. К тому же в вычислениях нам часто будет достаточно лишь возвести натуральное число в натуральную степень по модулю, то есть посчитать не значение выражения $x^n$, а значение выражения $x^n \mod m$.

И оказывается, что наивное перемножение числа $x$ с самим собой $n$ раз, со взятие каждый раз остатка по модулю $m$ не является оптимальным и \term{бинарное возведение в степень} работает быстрее. Основывается оно на формулах $x^{2k} = x^k \cdot x^k$ и $x^{2k + 1} = x \cdot x^k \cdot x^k$, при $k \in \set{Z}$ и двух частных случаях: $x^0 = 1$ и $x^1 = x$. Взятие же по модулю нужно делать после каждой операции умножения, чтобы не происходило переполнение типов данных.

Понятно, что сложность такого возведения в степень будет \O{\log n}, потому что на каждом шаге степень уменьшается в два раза, а значение для каждой степени достаточно вычислить один раз.


\subhead{Системы счисления}
Системы счисления не совсем описывают операции с числами, а занимаются только их представлением. Но всё же алгоритмы по переводу чисел между системами счисления также относятся к алгебре.

Позиционная система счисления характеризуется своим основанием ($b$) и по определению число $x = \overline{a_n a_{n - 1} \ldots a_1 a_0}_b = a_n \cdot b^n + a_{n - 1} \cdot b^{n - 1} + \ldots + a_1 \cdot b + a_0$ (черта сверху обозначает, что это одно число, а не произведение, индекс снизу — основание, для десятичной системы счисления мы его опускаем). Мы же займёмся переводами чисел из одной системы счисления в другую, через десятичную (сначала преобразуем любую систему в десятичную, а потом из десятичной научимся получать любую).

Преобразование в десятичную систему счисления можно делать по формуле выше: будем смотреть на знаки числа $x$ справа налево и сохранять текущую степень $b$ в переменную $y$, а итоговую сумму в переменную $z$. Изначально $y = 1. z = 0$, к $z$ добавляется $y \cdot a_0$. Потом мы переходим к следующему знаку и домножаем $y$ на $b$ (поскольку степень выросла) и повторяем операцию с добавлением. И так делаем со всеми знаками, получив число в десятичной системе счисления в переменной $z$.

Преобразовывать из десятичной системы счисления также не сложно. Для этого, пока у нас число $z$ не обнулится, будем делать следующую операцию: запишем в строку с ответом значение $z \mod b$, уменьшим на столько $z$ и перейдём к следующему знаку, поделив $z$ на $b$. Так мы получим строку, в которой знаки будут храниться в обратном порядке, ей нужно развернуть, и она станет итоговым числом в $b$-ричной системе счисления.

Сложность данных алгоритмов \O{n}, где $n$ — длина представления в $b$-ричной системе счисления.


\subhead{Теория чисел}
Все остальные алгебраические алгоритмы, которые мы пройдём, можно отнести к теории чисел (это раздел математики, изучающий свойства чисел). Поэтому сначала нужно повторить некоторые факты из теории чисел.

Во-первых, в математике есть удобные обозначения для множеств, которые мы будем использовать: $\set{N}$ — натуральные, $\set{Z}$ — целые, $\set{P}$ — простые. В разных источниках можно встретить разное отношение к числу 0, но мы будем считать, что 0 не натуральное число (но, конечно, целое): $0 \notin \set{N}, 0 \in \set{Z}$.

Во-вторых, в математике придумали специальное обозначение, которое показывает, что одно число ($a$) нацело делится на другое ($b$): $a \div b$.

И в-третьих, функция $f: \set{N} \to \set{Z}$ называется \term{мультипликативной}, если $f(n \cdot m) = f(n) \cdot f(m)$ для любых взаимно простых $n$ и $m$ (определение взаимно простых числах в разделе \hyperlink{euler_function}{функция Эйлера}).

Также существует основная теорема арифметики, которая гласит: любое натуральное число большее 1 ($n \in \set{N}, n > 1$) можно однозначно представить в виде произведения простых чисел в натуральных степенях:
$$n = p_1^{\alpha_1} \cdot p_2^{\alpha_2} \cdot \ldots \cdot p_s^{\alpha_s}, p_i \in \set{P}, \alpha_i \in \set{N}$$

При этом простым числом называется то, которое делится только на 1 и на само себя. А составным — число, у которого есть ещё другие делители. При этом 1 — не составное и не простое число.


\subhead{НОД и НОК}
НОД — это наибольшие общий делитель (наибольшее число, на которое другие делятся без остатка), в английском варианте — gcd (от \term{greatest common divisor}). Вообще НОД определён для набора чисел любой длины, но сначала разберёмся как его считать для двух чисел. Для вычисления НОД используется \term{алгоритм Евклида}, который основывается на следующий свойствах НОД'а:

\begin{itemize}
    \item $gcd(a, 0) = a$, при $a > 0$.
    \item $gcd(a, b) = gcd(a - b, b)$, при $a \geq b > 0$. Докажем это свойство. Обозначим $d = gcd(a, b)$ и $d' = gcd(a - b, b)$, тогда $a \div d$ и $b \div d$. А тогда и $(a - b) \div d$, значит $d' \div d$, значит $d' \geq d$. Но аналогично и $(a - b) \div d'$ и $b \div d'$. А тогда и $a = (a - b + b) \div d'$, значит $d \div d'$, значит $d \geq d'$. Но очевидно, что раз $d' \geq d$ и $d \geq d'$, то тогда $d' = d$, и исходное свойство доказано.
    \item $gcd(a, b) = gcd(a \mod b, b)$, при $a \geq b > 0$. Это свойство является следствием предыдущего, так как можно вычитать $b$ до тех пор, пока получается вычитать (пока второе число не меньше $b$). Но тогда у нас как раз получится пара $a \mod b$ и $b$.
\end{itemize}

Теперь можно и написать программу, которая смогла бы вычислять НОД по описанным выше свойствам. Это предлагается читателям реализовать самостоятельно.

НОК — это наименьшее общее кратное (наименьшее число, которое делится на другие без остатка), в английском варианте — lcm (от \term{least common multiple}). НОК, также, как и НОД, определён и для набора чисел, но пока мы вновь попробуем посчитать его для пары. Оказывается, что для этого достаточно использовать всего одно свойство:

\begin{itemize}
    \item $gcd(a, b) \cdot lcm(a, b) = a \cdot b$.
\end{itemize}

Доказывается оно через основную теорему арифметики:

\begin{enumerate}
    \item Представим оба числа ($a$ и $b$), как произведение простых, при этом получится два набора простых чисел. Теперь в разложение $a$ добавим те числа, которые получились в разложении $b$, но их нет в разложении $a$. Чтобы разложение осталось корректным сделаем эти числа в нулевых степенях. Аналогично дополним разложении $b$ и получим:
    $$a = p_1^{\alpha_1} \cdot p_2^{\alpha_2} \cdot \ldots \cdot p_s^{\alpha_s}$$
    $$b = p_1^{\beta_1} \cdot p_2^{\beta_2} \cdot \ldots \cdot p_s^{\beta_s}$$
    $$p_i \in \set{P}, \alpha_i \in \set{Z}, \alpha_i \geq 0, \beta_i \in \set{Z}, \beta_i \geq 0 $$
    \item Заметим, что НОД можно определить по другому, ведь:
    $$gcd(a, b) = p_1^{\min{(\alpha_1, \beta_1)}} \cdot p_2^{\min{(\alpha_2, \beta_2)}} \cdot \ldots \cdot p_s^{\min{(\alpha_s, \beta_s)}}$$
    Потому что другие делители брать нельзя, ведь тогда $d = gcd(a, b)$ не будет делиться на $a$ и $b$, аналогично у существующих делителей степень не может быть больше, так как тогда пропадёт одна из делимостей $a \div d$ или $b \div d$. Значит такой $d$ — действительно НОД этих чисел.
    \item Аналогичные рассуждения приводят к выводу о том, что:
    $$lcm(a, b) = p_1^{\max{(\alpha_1, \beta_1)}} \cdot p_2^{\max{(\alpha_2, \beta_2)}} \cdot \ldots \cdot p_s^{\max{(\alpha_s, \beta_s)}}$$
    \item И, наконец, заметим, что $\min{(x, y)} + \max{(x, y)} = x + y$.
    \item И теперь равенство становится совсем очевидным:
    $$gcd(a, b) \cdot lcm(a, b) = \big( p_1^{\min{(\alpha_1, \beta_1)}} \cdot p_2^{\min{(\alpha_2, \beta_2)}} \cdot \ldots \cdot p_s^{\min{(\alpha_s, \beta_s)}} \big) \cdot \big( p_1^{\max{(\alpha_1, \beta_1)}} \cdot p_2^{\max{(\alpha_2, \beta_2)}} \cdot \ldots \cdot p_s^{\max{(\alpha_s, \beta_s)}} \big) =$$
    $$= p_1^{\alpha_1 + \beta_1} \cdot p_2^{\alpha_2 + \beta_2} \cdot \ldots \cdot p_s^{\alpha_s + \beta_s} = \big( p_1^{\alpha_1} \cdot p_2^{\alpha_2} \cdot \ldots \cdot p_s^{\alpha_s} \big) \cdot \big(  p_1^{\beta_1} \cdot p_2^{\beta_2} \cdot \ldots \cdot p_s^{\beta_s} \big) = a \cdot b$$
\end{enumerate}

Теперь у нас есть формула, из которой мы можем выразить НОК: $lcm(a, b) = \frac{a \cdot b}{gcd(a, b)}$. А раз есть формула, то легко написать программу, которая бы по ней считала, что и предлагается сделать читателю.

Остаётся сказать, что сложность этих алгоритмов — \O{\log\min{(a, b)}}.

Если же чисел много, то с НОД'ом и НОК'ом можно работать вполне естественным образом:
$$gcd(a, b, c) = gcd(gcd(a, b), c); lcm(a, b, c) = lcm(lcm(a, b), c)$$


\subhead{Расширенный алгоритм Евклида}
Оказывается, что с помощью алгоритма Евклида можно получить \term{линейное представление НОД'а}, которое можно записать формулой $ax + by = gcd(x, y)$. Теперь попробуем разобраться, как получить коэффициенты $a$ и $b$ в зависимости от чисел $x$ и $y$.

По нашему определению выше $gcd(x, 0) = x$, при $x > 0$. Но, кроме этого, понятно, что в таком случае решением являются $a = 1$ и $b = 0$, ведь тогда $1 \cdot x + 0 \cdot 0 = x$. Поэтому для одного частного случая решения у нас есть, остаётся лишь понять формулу в общем виде.

Как мы определяли выше, $gcd(x, y) = gcd(x \mod y, y)$. Теперь представим, что мы уже знаем решение уравнение $a \cdot (x \mod y) + b \cdot y = gcd(x \mod y, y)$ и хочется получить решение уравнения $a'x + b'y = gcd(x, y)$. Остаётся лишь сделать немного математических преобразований: $a \cdot (x \mod y) + b \cdot y = gcd(x \mod y, y) = gcd(x, y) = a'x + b'y = a' \cdot (\left\lfloor\frac{x}{y}\right\rfloor \cdot y + x \mod y) + b'y = a' \cdot \left\lfloor\frac{x}{y}\right\rfloor \cdot y + a' \cdot (x \mod y) + b'y = a' \cdot (x \mod y) + (a' \cdot \left\lfloor\frac{x}{y}\right\rfloor + b') \cdot y$ (квадратные скобки в формуле обозначают округление числа вниз).

Понятно, что теперь мы имеем равенство $a \cdot (x \mod y) + b \cdot y = a' \cdot (x \mod y) + (a' \cdot \left\lfloor\frac{x}{y}\right\rfloor + b') \cdot y$, только вот как его решить? Для этого заметим, что в обеих частях равенства есть выражения $(x \mod y)$ и $y$, а значит если окажется, что коэффициенты при них равны, то мы получим верное равенство. Поэтому решим систему уравнений:

\[\begin{multisys}
    \begin{system}
        a = a' \\
        b = a' \cdot \left\lfloor\frac{x}{y}\right\rfloor + b'
    \end{system}
    \iff
    \begin{system}
        a' = a \\
        b' = b - a \cdot \left\lfloor\frac{x}{y}\right\rfloor
    \end{system}
\end{multisys}\]

Всё, теперь мы научились делать линейное представление НОД'а, ведь для конечного случая у нас есть явная формула, а в остальных ситуациях мы можем пересчитывать предыдущий ответ через следующий. В коде же это принято реализовывать с помощью рекурсивной функции, которая возвращает значение НОД'а, а коэффициенты $a$ и $b$ меняет по ссылке. Но не стоит заморачиваться с ссылками, ведь всегда можно вернуть из функции тройка чисел :)

К тому же понятно, что от наличия двух дополнительных формул, сложность алгоритма не изменилась и по-прежнему составляет \O{\log\min{(a, b)}}.


\subhead{Обратное число по простому модулю}
Пусть дано число $a$ и модуль $m$, тогда $a^{-1}$ называется обратным числом к $a$ и оно должно отвечать равенству $a \cdot a^{-1} \equiv 1{\pmod {m}}$ (три черты это остаток от деления).

Для поиска обратного числа нам поможет \term{малая теорема Ферма (МТФ)}, которая говорит, что при простом $p$ и $a$, которое на это $p$ не делится, выполняется равенство $a^{p - 1} \equiv 1{\pmod{p}}$. Докажем эту теорему.

Рассмотрим числа $a,\ 2a,\ 3a,\ \ldots,\ (p - 1)a$. Если так оказалось, что среди них есть два числа $a \cdot i$ и $a \cdot j$ ($i \ne j$), сравнимые по модулю $p$, то рассмотрим их: $a \cdot i \equiv a \cdot j {\pmod{p}}$, а значит $a \cdot (i - j) \equiv 0$. Но ведь наше $a$ на $p$ не делится по условию МТФ, а разность $|i - j| < p - 2$, то есть тоже не может делиться на простое число $p$. Следовательно предположение не верное и у всех этих чисел должны быть разные остатки при делении на $p$. Но понятно, что всего таких остатков $p$, при чём, очевидно нет такого, что $a \cdot i \equiv 0$, а значит для $p - 1$ числа остался всего $p - 1$ остаток, следовательно каждый остаток встречается ровно один раз. Перемножим все числа набора: $a \cdot 2a \cdot 3a \cdot \ldots \cdot (p - 1)a \equiv 1 \cdot 2 \cdot 3 \cdot \ldots \cdot (p - 1)$. И сократив на $(p - 1)!$ имеем: $a^{p - 1} \equiv 1$, что и утверждает МТФ.

А теперь посмотрим на условие обратности: $a \cdot a^{-1} \equiv 1 {\pmod{p}}$ и на МТФ: $a^{p - 1} = a \cdot a^{p - 2} \equiv 1 {\pmod{p}}$. И из них можно заключить вывод, что $a^{-1} \equiv a^{p - 2} {\pmod{p}}$.

Значит, чтобы узнать обратное число, нам потребуется всего лишь возвести число $a$ в степень $p - 2$ по модулю $p$, что можно сделать с помощью бинарного возведения в степень за \O{\log p}.
