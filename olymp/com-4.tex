\head{Жадные алгоритмы}
Перебор, который мы прошли раньше, требует очень больших временных затрат, поэтому существует много способов решать задачи быстрее. Одним из таких способов являются жадные алгоритмы — эти алгоритмы на каждом шаге поступают оптимально и получают оптимальный ответ. Сегодня мы разберём несколько примеров задач, в которых можно придумать жадный алгоритм, и после этого попытаемся доказать, что эти алгоритмы работают или нет.


\subhead{Транснеравенство}
Начнём мы изучать жадные алгоритмы с примера из математики: пусть у нас есть два набора чисел одинаковой длины: $a_1, a_2, \ldots, a_n$ и $b_1, b_2, \ldots, b_n$. Требуется так переставить элементы обоих наборов, чтобы найти максимум у выражения $\sum\limits_{i = 1}^{n} a_i \cdot b_i$.

Возникает естественное желание отсортировать оба набора и кажется, что тогда мы получим максимум у этого выражения. Давайте попробуем доказать, работает ли наш алгоритм.

Во-первых, давайте отсортируем элементы у набора $a$, ведь от перемены мест слагаемых в искомом выражении сумма не изменится, а делать рассуждения станет чуть проще.

Теперь разберём простой случай при $n=2$, пусть у нас $a_1 \leq a_2$ и $b_1 \leq b_2$. Собственно, для таких ограничений можно сделать только два варианта, поэтому нам останется проверить, что $a_1 \cdot b_2 + a_2 \cdot b_1 \leq a_1 \cdot b_1 + a_2 \cdot b_2$. Видимо, нужно перенести всё в одну сторону у перегруппировать слагаемые: $0 \leq a_1 \cdot (b_1 - b_2) + a_2 \cdot (b_2 - b_1)$, и ещё раз: $0 \leq (b_1 - b_2) \cdot (a_1 - a_2)$. А это уже очевидно, ведь $b_1 - b_2 \leq 0$ и $a_1 - a_2 \leq 0$.

Теперь разберём общий случай, когда $n>2$. Пусть у нас получился ответ больше, чем тот, который получается при отсортированных наборах. Тогда у нас набор $b$ не отсортирован по не убыванию, а значит найдётся два индекса $i < j$, для которых $b_i > b_j$ (для них пары $a_i$ и $a_j$ соответственно, при этом, мы раньше упорядочили: $a_i \leq a_j$). Тогда сумма, которую вносят эти два элемента будет $a_i \cdot b_i + a_j \cdot b_j$. Но, как мы доказывали раньше, для набора из двух элементов отсортированный вариант не меньше второго, а значит $a_i \cdot b_i + a_j \cdot b_j \leq a_i \cdot b_j + a_j \cdot b_i$ (так наборы отсортированы: $a_i \leq a_j$ и $b_j < b_i$). Следовательно мы можем поменять эти два элемента местами и ответ от этого не уменьшится.

То есть мы предположили, что найдётся ответ лучше нашего и доказали, что такого не бывает. В математике такой метод называется \term{от противного}.

Также стоит немного дополнить про транснеравенство. Наименьшее значение у суммы $\sum\limits_{i = 1}^{n} a_i \cdot b_i$ будет, если $a_1 \leq a_2 \leq \ldots \leq a_n$ и $b_1 \geq b_2 \geq \ldots \geq b_n$. Доказывается это точно также, только нужно предположить, что нашёлся ответ меньше :) А причина расположения транснеравенства именно в этой теме очевидна: мы можем на каждом шаге выбирать два таких числа ($a_i$ и $b_j$), что их произведение наибольшее (для этого возьмём наибольшие числа из обоих наборов), добавляем это произведение к ответу и удаляем эти два числа. Такой алгоритм как раз является жадным и при этом формирует нужное нам упорядочивание.


\subhead{Непрерывная задача о рюкзаке}
Задача о непрерывном рюкзаке формулируется так: вор пробрался на склад, где имеется $n$ вещей стоимостью $c_i$ и массой $m_i$. Нужно выбрать такие вещи, чтобы их суммарная масса не превосходила заданного $w$ (вместимость рюкзака), и при этом набрать максимальную стоимость. Вещи делимы, можно взять любую их часть и стоимость взятой части пропорциональна её массе.

Хочется действовать так: давайте вор каждый раз будет выбирать ту вещь, у которого максимальна цена за единицу массы; если вещь целиком не входит, то он возьмёт только её часть.

Теперь докажем верность алгоритма \term{методом минимального контрпримера}: предположим, что на каких-то наборах данных наш алгоритм не оптимален и среди всех этих наборов возьмём минимальный по количеству вещей. Далее посмотрим на самый выгодный предмет (тот, у которого $\frac{c_i}{m_i}$ максимально), наш жадный алгоритм брал его как можно больше. Если в контрпримере этого предмета меньше, то мы можем избавиться от части других предметов и заменить на самый выгодный, при этом общая набранная стоимость не уменьшится. А теперь мы знаем, что у нас и в жадном решении, и в контрпримере самый выгодный предмет взят в одинаковом количестве, а значит мы можем его удалить в обоих наборах и перейти к меньшему контрпримеру.

Но мы брали наименьший контрпример, а смогли найти тот, в котором предметов на один меньше. Понятно, что такого не бывает, а значит предположение, что есть контрпримеры — не верно.

Так, довольно компактно, мы смогли доказать верность жадного алгоритма. В целом, такой метод доказательства удобен, потому что позволяет смотреть только на один пример, при этом не требуется доказывать оптимальность жадного решения на нём, а нужно лишь перейти к меньшему примеру.

Сложность такого алгоритма будет \O{n \log n}, потому что элементы требуется отсортировать, а дальнейший выбор можно сделать за \O{n}.


\subhead{Задача о выборе заявок}
Пусть имеется $n$ заявок на проведение мероприятия в помещении. Каждая заявка характеризуется двумя временами: временем начала и временем конца ($l_i$ и $r_i$, значит помещение хотят занять на время $[l_i; r_i)$). Требуется выбрать как можно больше заявок так, чтобы помещение в каждый момент времени было занято не более, чем один раз.

Довольно естественно попытаться смоделировать выбор заявок во времени: пусть сейчас какой-то момент времени $t$, часть заявок уже отработана, часть — ещё нет, и нужно выбрать ещё одну заявку. Кажется, что хочется выбрать ту, которая раньше всех закончится. Давайте попробуем доказать верность такого выбора.

Снова воспользуемся методом минимального контрпримера: среди всех контрпримеров выберем тот, в котором меньше всего заявок. Теперь рассмотрим ту заявку, которая раньше всех заканчивается. В жадном решении эта заявка берётся на первом шаге. Если же в контрпримере нет этой заявки, то первая его заявка заканчивается позже, а значит, её можно заменить на ту, которая заканчивается раньше всех. Теперь у нас в обоих решениях есть эта самая ранняя заявка, а значит мы её можем удалить.

Так мы должны будем перейти к контрпримеру, в котором на одну заявку меньше, но такого нет, ведь мы брали контрпример с минимальным числом заявок. А значит предположение о наличии контрпримеров не верно, а следовательно жадное решение работает.

У этого алгоритма тоже сложность \O{n \log n} на сортировку и \O{n} займут оставшиеся операции.


\subhead{Задача о расписании}
Пусть имеется $n$ дел, которые нужно выполнить. Каждое дело выполняется за $1$ день, при этом его нужно начать не позже дня $d_i$ и за него мы получим $c_i$ монет. Нужно составить расписание так, чтобы заработать максимальное число монет.

Первое желание — каждый раз выполнять самой дорогое дело из доступных. Но можно легко придумать пример, когда наше жадное решение даст не верный ответ: пусть $n=2$, $d = [1, 2]$, $c = [1, 10]$. Тогда в первый день мы выполним второе дело, а во второй день будем отдыхать; итого мы сможем заработать $10$ монет. Но если сначала выполнить первое дело, а во второй день — второе, то мы сможем заработать больше — $11$ монет.

Второе возможное решение — также брать дела начиная с самого дорого, но выполнять их не сразу, а пытаться отложить на наиболее поздний срок. Во-первых, это хорошо, потому что решает предыдущий пример, а во-вторых — люди часто в обычной жизни всё откладывают на последний момент :)

Теперь снова попробуем доказать наш жадный алгоритм методом минимального контрпримера (успели его полюбить?). Среди всех контрпримеров найдём тот, в котором меньше всего дел. Теперь посмотрим на самое дорогое дело (пусть его индекс $i$). Оно точно есть в жадном решении, потому что оно возьмётся на первом шаге и поставится на день $d_i$. Если в контрпримере нет этого дела, то мы можем освободить день $d_i$ (если он не свободен) и поставить на него дело $i$ — так общий заработок только увеличится, а значит такой контрпример не был оптимальным (но очевидно, что такого не бывает). Следовательно, в контрпримере дело $i$ точно есть и выполняется в какой-то день $x$ (причём по условию $x \leq d_i$). Если $x < d_i$, то давайте поставим дело $i$ на день $d_i$, а если на этот день уже было запланировано какое-то другое дело, то переставим его на день $x$ (так точно можно, ведь день $x$ раньше). Теперь у нас и в жадном решении, и в контрпримере в день $d_i$ стоит дело $i$, а значит мы можем удалить это дело.

Мы снова перешли к контрпримеру, в котором на одно дело меньше, но так быть не может, ведь мы брали контрпример с наименьшим числом дел. А значит контрпримеров нет и наше жадное решение оптимально. Видно, что в данной задаче и доказательство немного сложнее, и сам алгоритм сложнее (как-никак, наш первый алгоритм не сработал).

Как это ни удивительно, но и у этого алгоритма такая же сложность, как и двух предыдущих: \O{n \log n} на сортировку и оставшаяся часть делается за \O{n}.


\subhead{Задача о размене}
И последняя задача в этой теме — задача о размене: имеется $n$ номиналов монет $a_1, a_2, \ldots, a_n$, количество монет каждого наминала не ограничено. Требуется набрать сумму $x$ наименьшим числом монет.

На что ж, попробуем действовать жадно: будем брать монеты в порядке убывания наминала, при этом каждую монету будем брать как можно больше раз. Но что-то этот алгоритм ломается на примере: $n = 3$, $a = [1, 3, 4]$, $x = 6$. Ведь наш жадный алгоритм возьмёт $3$ монеты: $[4, 1, 1]$, а оптимальнее было взять $2$ монеты: $[3, 3]$.

А вот другого жадного решения что-то не придумывается, а значит, вероятно, наша задача должна решаться как-то по-другому...
