\head{Другие возможности C++}
В данный блок попали те возможности C++, которые в олимпиадном программировании используются лишь частично, а потому их мы разберём поверхностно, чтобы иметь хоть какое-то представление о них. Если возникнет желание, то эти темы можно будет подучить, подробности в разделе \hyperlink{0.5}{образовательные ресурсы}.


\subhead{Структуры}
\term{Структуры} позволяют определять пользовательские типы данных. Например, давайте рассмотрим точку на декартовой плоскости (у неё две координаты: $x$ и $y$). Вполне естественно, что хочется, чтобы с этой точкой можно было работать, как с единым целым. Например, узнавать её полярные координаты (угол $\varphi$ и расстояние $\rho$), или же узнавать расстояние между точками. И, чтобы объединить данные и функции вместе и существует структуры.

Чтобы определить такую структуру понадобится написать вот такой код:

\cpp{8}{3}

И в программе (например, в \lcpp{main}) её можно будет использовать так:

\cpp{8}{2}

Использовать структуры совсем просто — точно также, как и встроенные типы. Например, можно создать \lcpp{vector} точек:

\cpp{8}{1}

Определение же структуры чуть сложнее. Например, можно создать \term{конструктор}, который всегда вызывается при создании \term{объектов} (в нашем случае — точка \lcpp{p}). Размещать такой конструктор нужно внутри класса (между фигурными скобками):

\cpp{8}{4}

Здесь, для доступа к данным создаваемой точки используется \lcpp{this ->}, такой же синтаксис можно использовать и для других \term{методов} (функций класса). Например, научимся определять расстояние от точки до начала координат:

\cpp{8}{4}

Пользоваться методами тоже просто:

\cpp{8}{1}

Теперь давайте сделаем функцию, вычисляющую расстояние между двумя точками:

\cpp{8}{3}

Теперь воспользуемся ей:

\cpp{8}{3}

И, напоследок, определим операцию \lcpp{-p}, она будет отражать точку относительно начала координат, меняя обе координаты на противоположные:

\cpp{8}{3}

Остаётся немного сказать о конструкторе. В нём, как и в других функциях можно использовать значения по умолчанию:

\cpp{8}{1}

Также, выражения вида \lcpp{this -> x = x} придумали упрощать следующим способом (так можно только в конструкторах):

\cpp{8}{1}

Теперь можно передавать не все координаты в конструктор:

\cpp{8}{3}

Кончено, это только малая часть теории по структурам, но уже этого должно хватать для олимпиадного программирования (там используются структуры в очень ограниченном числе случаев). В курсах, о которых говорилось в начале раздела, можно узнать больше (а там ещё много интересного).


\hypertarget{built-in function}{}
\subhead{Встроенные функции}
Теперь кратко рассмотрим полезные для олимпиадного программирования встроенные функции.

Во-первых, есть много встроенных математических функций (\lcpp{sin}, \lcpp{atan2}, \lcpp{sqrt} и т.д.), для его использования нужно подключить файл:

\cpp{8}{1}

Во-вторых, иногда нужно вывести дробное число, а оно выводится не так, как нужно, например:

\cpp{8}{1}

Чтобы такого не происходило, нужно подключить файл, в котором содержатся способы влияния на \lcpp{cout}:

\cpp{8}{1}

И написать в начале программы:

\cpp{8}{2}

В-третьих, иногда бывают нужны случайные числа, они генерируются вот так:

\cpp{8}{5}

Но такой способ генерирует только 16-битные числа, поэтому в C++11 появился новый способ рандомить:

\cpp{8}{7}

И ещё в C++ есть встроенные алгоритмы, которые тоже находятся в отдельном файле:

\cpp{8}{1}

Теперь рассмотрим те функции, которые нам понадобятся в олимпиадном программировании:

\cpp{8}{10}

Если операции нужно совершить не с массивом, а, например с \lcpp{vector}'ом, то нужно использовать итераторы (да-да, тут-то они нам и понадобились):

\cpp{8}{2}

Ещё в сортировку можно передать функцию, по которой и будут упорядочиваться элементы:

\cpp{8}{4}

Помните, что \lcpp{set} и \lcpp{map} сами как-то упорядочиваются? Так вот, по умолчанию они используют \lcpp{operator<} для типа, который хранят. Но если вам не нравится, как элементы упорядочиваются, то можно передать свой \term{компаратор}:

\cpp{8}{6}

Интересный (и бесполезный) факт, что делать \lcpp{swap} двух целочисленных переменных можно и формулой:

\cpp{8}{1}


\subhead{Стек, очередь и дек}
Корме популярных контейнеров, которые мы рассмотрели раньше, существуют также и менее используемые, но всё равно очень важные структуры данных: стек, очередь и дек. У них много общего, поэтому мы пройдём их вместе.

Стек довольно бесполезная структура, так как \lcpp{vector} имеет все возможности стека, но тем не менее, в C++ всё же отдельно есть \lcpp{stack}. Представлять себе стек можно как стопку монет, на которую сверху можно добавить монету, или забрать верхнюю монету. Используется он вот так:

\cpp{8}{6}

Следующая структура — очередь \lcpp{queue}. Это как очередь на кассе: в её конец может встать человек, или человек может уйти из её начала. Вот пример работы с ним:

\cpp{8}{7}

И последняя структура — дек. Это обобщение двух предыдущих структур, так как и в начало дека, и в конец дека можно добавлять и удалять элементы. Вот, как это выглядит в коде:

\cpp{8}{14}

Это основные функции, которые есть у данных структур. Ещё, также, как и у других контейнеров, есть методы \lcpp{size}, который возвращает размер, и \lcpp{empty}, проверяющий контейнер на пустоты. Также нужно добавить, что для этих структур нужно подключить соответствующие файлы:

\cpp{8}{3}


\hypertarget{macros}{}
\subhead{Макросы}
Теперь рассмотри \term{макросы} — наследие C, которое позволяет генерировать код. Макросы обрабатываются перед компиляцией программы: в месте его использования просто подставляется тело макроса, и только после этого начинается компиляция, где может выявиться, например, синтаксическая ошибка, возникшая при подстановке макроса.

Рассмотрим простой пример использования макроса:

\cpp{8}{1}

Такая запись говорит, что везде, где встретится \lcpp{INF} вместо него нужно будет подставить \lcpp{2e9}. Но отметим, что вместо макроса можно было бы вполне использовать переменную:

\cpp{8}{1}

Ещё один пример — сокращение имён типов:

\cpp{8}{1}

Но это тоже можно написать более современным способом:

\cpp{8}{1}

Другой пример — это упрощение вывода для контейнеров, сделать это можно так:

\cpp{8}{1}

Использовать же этот макрос можно будет вот так:

\cpp{8}{4}

Если макрос не влезает в одну строку, то его можно перенести с помощью \lcpp{\}, поставленной в конце строки с кодом. Макросы — это довольно интересная возможность C++, но злоупотреблять ими не стоит. В следующем разделе мы представим основные макросы, которые используются, но если нужно, то, конечно, стоит самим писать удобные для себя макросы.


\subhead{Шаблоны}
В C нельзя было создавать функции с одинаковым именем, но с разными получаемыми значениями (это называется \term{перегрузка}), поэтому там, например, была функция \lcpp{abs} отдельно для каждого типа, и все с разными названиями. В C++ решили, что нужно это исправить и придумали \term{шаблоны}. В простейшем случае шаблоны нужны, чтобы не дублировать код для разных типов данных, а написать его лишь один раз для \term{шаблонного типа}.

Напишем функцию \lcpp{func}, которая будет сама вычислять минус модуль числа (не использую встроенную функцию \lcpp{abs}):

\cpp{8}{4}

И вызывать эту функцию можно так:

\cpp{8}{4}

И во время компиляции для каждого используемого типа будет сгенерирована своя функция. Понятно, что в этом примере вместо \term{шаблонной функции} можно было использовать макрос, но, во-первых, тогда бы пришлось передавать в макрос ещё и тип, а во-вторых, макрос просто подставляет текст. тогда как шаблоны генерируют код.

Ещё одно использование шаблонов — контейнеры, с которыми мы познакомились. Там используются \term{шаблонные классы}, параметры которых мы передаём в треугольных скобках. Например, когда мы пишем \lcpp{vector<int>}, то компилятор находит шаблонный класс \lcpp{vector}, и генерирует его для типа \lcpp{int}.

Также, раз у нас есть код, генерируемый во время компиляции, то возникает желание посчитать что-нибудь во время компиляции, используя шаблоны. Так действительно можно, и это называется \term{метапрограммированием}. 

Давайте посмотрим, как во время компиляции посчитать факториалы:

\cpp{8}{8}

Правда, пользоваться этим придётся чуть необычно:

\cpp{8}{1}

Но есть и проблема — такая программа дольше компилируется и нельзя посчитать факториал числа, не известного во время компиляции. Факториалы тоже можно по-другому посчитать во время компиляции:

\cpp{8}{3}

И пользоваться этим удобно:

\cpp{8}{3}

Это работает, потому что слово \lcpp{constexpr} говорит, что функцию для констант нужно посчитать во время компиляции, а для не констант - во время выполнения.

Но, чтобы читатель осознал всю мощь и необходимость шаблонов, приведём вот такой пример части программы на C++11, которая умеет распаковывать \lcpp{tuple}'ы, передавать эти значения в функцию, и всё это вычислять (в последующих стандартах этот код стало можно писать чуть короче, а потом и вовсе для этого появилась встроенная функция \lcpp{apply}). Код оставим без комментариев, чтобы читателю было интересней самому понять, что в нём происходит:

\cpp{8}{5}

Шаблоны C++ позволяют делать очень много, и читателю стоит с ними разобраться подробнее, если он хочет научиться хорошо программировать на C++. Также, всегда стоит использовать шаблоны вместо макросов (если это возможно).
