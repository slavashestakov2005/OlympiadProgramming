\head{Множества и отображения}
В прошлом блоке мы узнали, как хранить много данных в одной переменной. Но что, если нам нужно не просто хранить данные, а и поддерживать какие-то их свойства. Например, всегда хранить только по одной копии для равных элементов (проще говоря, удалять повторы). Что тогда делать?

Для таких целей в C++ можно использовать \lcpp{set}! Во-первых, как обычно, придётся подключить заголовочный файл:

\cpp{7}{1}

Теперь можно и создать множество:

\cpp{7}{1}

У множеств логика составления названия типов такая же, как и у \lcpp{vector}: сначала пишется \lcpp{set}, чтобы обозначить, что нам нужно множество, а в \lcpp{<>} указывается тип элементов множества (в нашем случае \lcpp{int}).

Если нужно, то можно при объявлении задать элементы множества:

\cpp{7}{1}

Но в C++ множество не только хранят каждое значение по одному разу, но и при этом хранит их в отсортированном порядке. И поэтому внутри \lcpp{prime} окажется не \lcpp{{7, 3, 5, 2, 7}} и не \lcpp{{7, 3, 5, 2}}, а \lcpp{{2, 3, 5, 7}}.

Теперь можно перечислить основные методы у множеств:

\cpp{7}{16}

Важное отличие множеств от предыдущих контейнеров — это отсутствие доступа к элементам по индексам, то есть вот так выводить элементы нельзя:

\cpp{7}{1}

Но варианты с итераторами и \term{range-based for loop} продолжают работать:

\cpp{7}{4}

Теперь, изучив множества, можно и переходить к отображениям. Отображение — структура данных, которая хранит пару ключ-значение. Например, так устроена телефонная книга: по номеру телефона (ключ) можно узнать имя абонента (значение). При этом нет ограничения на повтор значений (у разных номеров вполне может быть один владелец).

В C++ такой тип данных — \lcpp{map}. Кроме перечисленных выше свойств, у \lcpp{map} есть ещё два: во-первых, не могут повторяться ключи, во-вторых, ключи автоматически сортируются. Подключить и создать его можно так:

\cpp{7}{3}

Во втором случае после создания \lcpp{map} (и сортировки ключей) данные будут храниться в таком порядке: \lcpp{{{1, "Bob"}, {2, "Eva"}, {3, "Alice"}}}.

Теперь, как обычно, перечислим основные методы у отображений:

\cpp{7}{17}

Можно заметить, что у \lcpp{map} довольно много общего с \lcpp{set}. Аналогично, у \lcpp{map} нет простого доступа к элементам по их порядковому номеру (как в массивах), поэтому вновь помогут циклы с итераторами и \term{range-based for loop}:

\cpp{7}{7}

По вызовам \lcpp{it -> first} и \lcpp{x -> second} (а также по типу \lcpp{pair<int, string>}) можно догадаться, что при итерировании по элементам \lcpp{map} нам на самом деле дают пару (\lcpp{pair}), где первое поле - ключ, а второе - значение. И это действительно так.

В стандарте 2017-го года появилось \term{структурное связывание}, которое используется в последнем цикле, из-за чего он выглядит особенно приятно. Если нужно менять значения, которые получены из структурного связывания, то нужно добавить амперсанд (\lcpp{&}), так как без него происходит копирование значений:

\cpp{7}{4}

На этом можно считать, что \lcpp{map} мы изучили. Но ...

Оказывается, что в C++ больше одного типа для множеств и отображений (так как C++ старается предоставить простые структуры на все случаи жизни). И поэтому существуют ещё модификации \lcpp{unordered} и \lcpp{multi}:

\starttable
    \begin{tabular}{|c|c|c|}
    \hline
        & \multicolumn{2}{c|}{Сортированность} \\
        \cline{2-3}
        \raisebox{1.5ex}[0cm][0cm]{Тип}
        & ordered & unordered \\
    \hline
    Множество & \lcpp{set} & \lcpp{unordered_set} \\
    Мультимножество & \lcpp{multiset} & \lcpp{unordered_multiset} \\
    Отображение & \lcpp{map} & \lcpp{unordered_map} \\
    Мультиотображение & \lcpp{multimap} & \lcpp{unordered_multimap} \\
    \hline
    \end{tabular}
\endtable

Типы, у которых в названиях есть \lcpp{multi} отличаются тем, что могут хранить несколько одинаковых элементов для \lcpp{set} и несколько одинаковых ключей для \lcpp{map}. \lcpp{unordered} типы отличаются тем, что в них элементы не упорядочены.

Основный отличием \lcpp{multi} контейнеров, с точки зрения кода, будет удаление элементов:

\cpp{7}{6}

\lcpp{unordered} контейнеры тоже имеют некоторые отличия от своих сортированных версий. А именно: у них нет методов \lcpp{lower_bound} и \lcpp{upper_bound}, но есть много новых методов, без которых в олимпиадном программировании вполне можно обойтись. Такое отличие связанно с реализацией самой структуры, которая не позволяет совершать эти операции эффективно (несортированные структуры используют \term{хэш-таблицы}, тогда как в сортированных — \term{бинарное дерево поиска}).

На этом изучение множеств и отображений заканчивается.
