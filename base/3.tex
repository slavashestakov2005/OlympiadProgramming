\hypertarget{1.3}{}
\head{Операторы}
Раз уж мы узнали про типы данных, то теперь можем начать ими пользоваться. Начнём с того, что операторы в C++ бывают унарные, бинарные и тернарные. Они принимают соответственно один, два или три аргумента. Ещё операторы разделяются по области применения на арифметические, сравнения, логические, побитовые, присваивания и другие. Посмотрим же на те операторы, которыми мы будем пользоваться, и на их функционал по умолчанию (в C++ можно \term{перегружать} операторы, но пока мы это не рассматриваем).
\begin{itemize}
    \item Арифметические унарные. К таким операторам можно отнести \lcpp{+a} и \lcpp{-a}. Эти операции в C++ имеют такой же смысл, как и в математике. Но при этом мы можем после плюса или минуса писать не только число но и символ, например вот так: \lcpp{+'a'}, и в данном примере значение этого выражения — \lcpp{97}. Но это мы обсудим чуть позже, а пока продолжим изучать другие операторы.
    \item Арифметические бинарные: \lcpp{a + b}, \lcpp{a - b}, \lcpp{a * b}, \lcpp{a / b}, \lcpp{a % b}. С первыми четырьмя операторами вновь всё понятно, потому что они заимствованы из математики. А вот на пятой операции, называемой остатком от деления, нужно немного остановиться. Вообще, такой термин существует и в математике, но там он определяется как число $r$ являющееся решением уравнения $a=bq+r$, где $0 \leq r < |b|$. Но в C++ это реализовано немного по-другому. Во-первых, остаток от деления работает только для целых чисел. Во-вторых, модуль значения определяется по тем же правилам, что и в математике, но знак получается таким же, как и у делимого (\lcpp{a}). Давайте посмотрим это на примере.
        
        \starttable
        \begin{tabular}{|c|c|c|c|}
        \hline
            & \multicolumn{3}{c|}{Значение} \\
            \cline{2-4}
            \raisebox{1.5ex}[0cm][0cm]{Выражение}
            & Математика & C++ & Python \\
        \hline
        \lcpp{5 % 3} & 2 & 2 & 2 \\
        \lcpp{5 % -3} & 2 & 2 & -1 \\
        \lcpp{-5 % 3} & 1 & -2 & 1 \\
        \lcpp{-5 % -3} & 1 & -2 & -2 \\
        \hline
        \end{tabular}
        \endtable
    
    Вот так устроен остаток от деления в C++, поэтому если у Вас какие-то переменные могут принимать отрицательные значения, то остаток от деления нужно использовать аккуратно, или не использовать вовсе.
    
    \item Несколько более интересные арифметические операторы это инкремент (\lcpp{++}) и декремент (\lcpp{--}). Первый из них увеличивает значение переменной на 1, второй — уменьшает. Но, при этом, у этих операторов есть префиксный вариант (\lcpp{++a} и \lcpp{--a}) и постфиксный вариант (\lcpp{a--} и \lcpp{a--}). Префиксный вариант сначала изменяет значение переменной, и уже потом его возвращает, а вот постфиксный — запоминает старое значение, изменяет значение, и потом возвращает старое значение. Понятнее это будет на примере:
    
    \cpp{3}{5}
    
    В олимпиадном программировании принято использовать префиксные варианты, потому что они немного быстрее постфиксных, так как не требуют запоминать старое значение переменной (хотя на самом деле компилятор достаточно умный, чтобы сгенерировать самый эффективный вариант кода).
    
    \item С операторами сравнения (они все бинарные) всё легче. Такие операторы это: \lcpp{a == b} (проверка на равенство), \lcpp{a != b} (проверка на неравенство), \lcpp{a < b} (проверка на меньше), \lcpp{a <= b} (проверка на меньше или равно), \lcpp{a > b} (проверка на больше), \lcpp{a >= b} (проверка на больше или равно). Этих операций нам будет достаточно, но для общего развития стоит сказать, что в стандарте C++ 2020-го года появился \term{оператор трёхстороннего сравнения} (неформальное название \term{космический корабль}), и выглядит он вот так: \lcpp{a <=> b}.
    
    \item Логические операторы это НЕ (\lcpp{!a}), ИЛИ (\lcpp{a || b}) и И \lcpp{a && b}. Принцип их работы таков: сначала вычисляется значение \lcpp{a}, потом он приводится к типу \lcpp{bool}. Если этого недостаточно, чтобы однозначно определить значение выражения, то потом уже и \lcpp{b} вычисляется и приводится к типу \lcpp{bool} (понятно, что для НЕ это не актуально, так как там всего один операнд). С НЕ всё просто — этот оператор возвращает противоположное значение для переменной (если была \lcpp{true}, то вернёт \lcpp{false} и наоборот). Что же касается для других операторов, то они вычисленные значения из \lcpp{bool} превращают в целые числа (\lcpp{true} становится 1, \lcpp{false} становится 0) и потом используют одноимённые побитовые операторы, про которые написано ниже.
    
    \item Унарный побитовый оператор — это инверсия (\lcpp{~a}). Она смотрит на каждый бит двоичного представления и изменяет его на противоположный (0 на 1, 1 на 0). При этом в C++ все побитовые операции определены для целых чисел, поэтому узнать значение \lcpp{~2.5} не получится, но \lcpp{~3} и даже \lcpp{~-5} являются корректными выражениями.
    
    \item Часть бинарных побитовых операторов это: сдвиг влево (\lcpp{a << b}) и сдвиг вправо (\lcpp{a >> b}). Они дописывают \lcpp{b} нулей в двоичное представление числа \lcpp{a} и после этого оставляют столько битов, сколько было в числе \lcpp{a} (сдвиг влево дописывает нули справа, как бы сдвигая исходное значение влево; со сдвигом вправо — наоборот). Согласно такому определению, данные операции равносильны домножению на степень двойки, а именно: \lcpp{c = a << b} то же самое, что и $c = a \cdot 2^b$, а \lcpp{c = a >> b} это $c = \Big\lfloor \frac{a}{2^b} \Big\rfloor$ (целая часть от деления).
    
    \item Оставшиеся бинарные операторы это: побитовое ИЛИ (\lcpp{a | b}), побитовое И (\lcpp{a & b}) и побитовое исключающее ИЛИ, оно же XOR (\lcpp{a ^ b}). Они последовательно смотрят на все биты операндов и получают значение ответа (по первыми битам \lcpp{a} и \lcpp{b} определяется первый бит ответа, по вторым — второй и т.д.). Ответ же определяется по всем известным таблицам истинности:
    
        \starttable
        \begin{tabular}{|c|c|c|c|c|}
        \hline
        \lcpp{a} & \lcpp{b} & \lcpp{a | b} & \lcpp{a & b} & \lcpp{a ^ b}\\ 
        \hline
        0 & 0 & 0 & 0 & 0 \\
        0 & 1 & 1 & 0 & 1 \\
        1 & 0 & 1 & 0 & 1 \\
        1 & 1 & 1 & 1 & 0 \\
        \hline
        \end{tabular}
        \endtable
    
    \item Операторов присваивания в C++ много. Самые простой, которым мы уже пользовались, это \lcpp{a = b}. Кроме обычного присваивания бывает ещё и составное присваивание, оно есть у каждого бинарного арифметического оператора и бинарного побитового оператора и записывается как \lpy{a @= b}, где \lpy{@} это собственно и есть наш оператор. И такая запись эквивалентна записи \lpy{a = a @ b}, например \lcpp{x += 2} тоже самое, что и \lcpp{x = x + 2} (и то, и другое увеличивают значение \lcpp{x} на 2).
    
    \item К другим операторам были отнесены те, которые нужны реже, и с ними будет проще разобраться потом, когда будут конкретные программы. Но, всё же, единственный тернарный оператор в C++ стоит рассмотреть сейчас. На первый взгляд, выглядит страшно: \lcpp{a ? b : c}, но это только так кажется. А работает он просто: сначала вычисляется выражение \lcpp{a} и приводится к \lcpp{bool}, если получилось \lcpp{true}, то результатом будет значение выражения \lcpp{b}, если \lcpp{false} — то значение \lcpp{c}.
\end{itemize}

Теперь все основные операторы можно считать изученными! Стоит лишь добавить, что разные выражения с операторами можно комбинировать между собой. При этом, стоит учитывать, что существует приоритет операций, и он влияет на порядок вычисления выражения, и, собственно, на его значение. Весь порядок приоритета операций учить довольно бесполезно, но можно запомнить, что унарные операции важнее, чем бинарные \lcpp{*}, \lcpp{/}, \lcpp{%}. Они, в свою очередь, важнее, чем бинарные \lcpp{+}, \lcpp{-}. Далее идут сравнения вперемешку с битовыми операциями, потом \lcpp{&&}, \lcpp{||}, и далее тернарный оператор и присваивания. Если сомневаетесь в приоритете операций, то можно поставить лишние круглые скобки, и они заставят сначала вычислить значение внутри них, и уже после этого с данным значением будет делаться окружающие его операции.

Теперь вроде бы мы всё знаем, кроме объяснения такой проблемы, как \lcpp{+'a'}, которое равно \lcpp{97} (смотрите самое начало темы). А на самом деле, здесь тоже нет ничего не правильного, ведь в C++ тип \lcpp{char} тоже является целым числом, и поэтому с ним можно делать операции, как с числами. Вы спросите: "Но почему же тогда именно \lcpp{97}?" А потому, что преобразование происходит не произвольно, а согласно \term{таблице символов ASCII}, и там у буквы \lcpp{'a'} именно такой код.

Следующий разумный вопрос: а к какому из целочисленных типов приводится \lcpp{char}, ведь мы в прошлый раз изучили, что их много? Здесь просто договорились, что таким универсальным типом, к которому всё приводится, если нужно, будет \lcpp{int}.

Теперь у Вас может возникнуть новый вопрос: "А что произойдёт, если в одном выражении будет стоять несколько разных числовых типов?" Ответ таков: всё значение выражение приводится к самому информативному из тех типов, которые есть в выражении. Например, если есть \lcpp{long long} и \lcpp{int}, то результатом операции с ними будет \lcpp{long long}; если были \lcpp{float} и \lcpp{double} то результатом будет \lcpp{double}; если \lcpp{int} и \lcpp{double} — то будет \lcpp{double}.

И, в связи с этим, нужно сделать важную оговорку про деление (\lcpp{a / b}). Если окажется, что оба операнда — целые числа, то и результат тоже будет целым числом (произойдёт целочисленное деление). Поэтому не стоит надеяться, что \lcpp{3 / 2 == 1.5}, так как сначала произойдёт деление и получится \lcpp{1}, и только потом будут сравниваться \lcpp{1 == 1.5}, а это, очевидно, \lcpp{false}. Чтобы поделить не нацело, нужно сделать какой-то из операндов не целым, например значение выражения \lcpp{3.0 / 2 == 1.5} уже будет \lcpp{true}.





