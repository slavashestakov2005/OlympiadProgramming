\head{Синтаксис C++}
В этом блоке мы изучим базовую часть синтаксиса C++ (на самом деле, весь синтаксис очень обширный, и в таком объёме он в олимпиадном программировании не требуется).

В прошлый раз мы изучили операторы, а до этого мы узнали про типы данных. Значит, мы уже можем написать какую-нибудь простенькую программу на C++, например, мы можем вычислить корни квадратного трёхчлена по его коэффициентам. Такая программа вполне может выглядеть вот так:

\cpp{4}{9}

Собственно, мы натыкаемся на проблему: если бы мы знали, что у вводимого квадратного уравнения всегда будет положительный дискриминант, то легко бы посчитали оба его корня, но ведь нам этого никто не обещал, а значит, нужно что-то придумать. Первой идеей может быть тернарный оператор, но это плохо, потому что по стандарту C++ такой оператор должен всегда возвращать одинаковое значение, но у нас не так, ведь корней то два, то ноль (или один, если рассматривать такой случай с двумя совпавшими корнями отдельно).

И здесь нам на помощь приходят условия! В C++ они выглядят вот так:

\cpp{4}{7}

Собственно, в начале идёт \term{ключевое слово} \lcpp{if}, потом в круглых скобках значение, истинность которого нужно проверить (для этого компьютер автоматически приведёт его к типу \lcpp{bool}), и потом в фигурных скобках идут операции, которые нужно выполнить (если операция ровно одна, то фигурные скобки можно опустить). Потом может идти сколько угодно (в том числе 0) блоков \lcpp{else if}, которые будут выполнены, если их условие истинно, а все предыдущие — нет. После всех \lcpp{else if} может идти (а может и не идти) блок \lcpp{else}, который выполнится, если все предыдущие условия не верны.

И понятно, что теперь мы можем написать задуманное вот таким образом (тот фрагмент кода, где мы сомневались):

\cpp{4}{10}

Если вы попробуете запустить, то вам выдадут ошибку \lmd{error: 'sqrt' was not declared in this scope} (ошибка: 'sqrt' не был объявлен в этой области видимости). Тае происходит, потому что для использования функции корня нужно подключить соответствующий файл:

\cpp{4}{1}

Конечно, \lcpp{if} — это уже хорошо, но также стоит сказать, про существование \lcpp{switch}, хотя и без него вполне можно обойтись. \lcpp{switch} нужно использовать, когда Вам нужно выбрать часть кода в зависимости от одного целочисленного выражения (например, если \lcpp{x} равно 1, то выполнить одно, если 2 — то другое, и т.д.). Давайте просто приведём пример использования \lcpp{switch}, так как он покрывает все тонкости использования данного оператора.

\cpp{4}{25}

Хорошо, будем считать, что с одной задачей справились, поэтому давайте придумаем другую. Например, будем вычислять $n$-ое число Фибоначчи (числа Фибоначчи определяются как $F_0 = 0, F_1 = 1, F_n = F_{n - 2} + F_{n - 1}$, при $n \ge 2$). Понятно, что согласно такому определению, нам для вычисления нужного числа понадобится вычислить предыдущие, для них - пред предыдущие и т.д. И как мы будем такое решать?

Вообще-то если очень хочется, то такое мы уже можем решить: мы знаем как устроен \lcpp{if}, а значит можем для каждого вводимого \lcpp{n} можем сделать своё условие и вывод. Но чувствуется же, что это не рационально, да?

И здесь нам на помощь приходят циклы! В C++ их аж 3 штуки, и они выглядят вот так:

\cpp{4}{9}

Давайте с ними разбираться. Общее во всех циклах — тело. Это, собственно, тот код, который нужно повторять каждый раз, пока длится цикл. Причём во всех циклах тело нужно писать в фигурных скобках, если совершается много операций, но если операция только одна, то фигурные скобки можно опустить. Как выполнение цикла завершается, то программа начинает выполняться со строки, следующей сразу после цикла. Теперь разберёмся с каждым циклом отдельно.

Первый цикл — \lcpp{for}. В нём мы сначала объявляем нужные для цикла переменные (\lcpp{x}), потом пишем условия выхода из цикла (\lcpp{y}), потом пишем шаг цикла (\lcpp{z}), и далее тело. Как работает это цикл? Сначала один раз выполняется \lcpp{x}, потом проверяется \lcpp{y}, далее выполняется тело цикла и шаг цикла. Потом происходит проверка условия (вычисляется \lcpp{y} и приводится к \lcpp{bool}) и если условие оказалось \lcpp{true}, то цикл продолжается: выполняется тело, делается шаг и вновь происходит проверка условия, если же \lcpp{y} оказался \lcpp{false}, то выполнение цикла завершается.

Второй цикл — \lcpp{while} несколько проще. Сначала проверяется условие (вычисляется \lcpp{x} и приводится к \lcpp{bool}), если условие \lcpp{true}, то выполняется тело цикла, если оказалось \lcpp{false}, то выполнение цикла завершается.

Третий цикл — \lcpp{do while} почти такой же, как \lcpp{while}. Сначала выполняется тело цикла, потом проверяется условие (вычисляется \lcpp{x} и приводится к \lcpp{bool}), если условие \lcpp{true}, то вновь начинает выполняться тело цикла, если оказалось \lcpp{false}, то выполнение цикла завершается.

Теперь мы знаем циклы и можем легко вычислять $n$-ое число Фибоначчи. Например, можно написать программу так: сначала вводится число \lcpp{n}, если оно 0 или 1, то эти случаи можно сделать по определению чисел Фибоначчи (потому что $F_0 = 0$ и $F_1 = 1$, а это и есть нужные нам ответы). А во всех других случаях давайте хранить два последних числа Фибоначчи (\lcpp{a} и \lcpp{b}), по ним вычислять следующее (\lcpp{c}), и потом обновлять последние числа. И после нужного числа итераций (шагов цикла) можно будет вывести ответ. Давайте напишем примерный алгоритм:

\cpp{4}{5}

А теперь будем использовать циклы. Сначала \lcpp{for}:

\cpp{4}{5}

Теперь с помощью \lcpp{while}:

\cpp{4}{7}

И, наконец, с помощью \lcpp{do while}:

\cpp{4}{7}

Можно запустить эти циклы и убедиться, что они дадут одинаковые ответы. По данному примеру может показаться, что всегда удобнее всего пользоваться циклом \lcpp{for}, но это не так, потому что бывают разные ситуации, и в каких-то из них нагляднее оформить цикл с помощью \lcpp{while}, и такой пример мы ещё разберём, но чуть позже.

Ещё в C++ есть ключевое слово \lcpp{break}, которое незамедлительно прекращает выполнение цикла, а также \lcpp{continue}, которые прерывает текущую итерацию и переходит к следующей (с проверкой условия и шагом цикла). Если в программе будет несколько циклов, один внутри другого (такие циклы называются вложенными), то \lcpp{break} и \lcpp{continue} повлияют только на один цикл, непосредственно в котором они и написаны.

Также стоит немного поговорить об \term{областях видимости}. В C++ все фрагменты кода, которые заключены между фигурными скобками, имеют свою область видимости, а это значит, что если в них объявить какую-нибудь переменную, то вне этой области видимости узнать значение этой переменной будет нельзя. То есть, в примерах выше, вне цикла нельзя написать, например, так:

\cpp{4}{2}

А что делать, если придётся, например, решать квадратные уравнения раз 10 в разных местах программы? Не писать же каждый раз одно и то же? Конечно нет, ведь в C++ есть функции!

Функция — это часть программы, которая принимает определённые аргументы, что-то делает с ними и после этого возвращает какое-то значение.
В нашем примере функцией вполне можно сделать вычисление дискриминанта. Принимаемыми аргументами будут коэффициенты квадратного трёхчлена, а возвращаемым значением — собственно, само значение дискриминанта. Посмотрим, же, как это сделать в C++:

\cpp{4}{4}

Что же здесь произошло? Объявление функции начинается с её возвращаемого значение и имени после него (\lcpp{double get_d}). После этого в круглых скобках перечисляются аргументы функции через запятую: сначала тип, потом значение \lcpp{double a, double b, double c}. И после этого идёт само тело функции, у которого фигурные скобки обязательны. Чтобы вернуть значение из функции, используется ключевое слово \lcpp{return}, и после него указывается возвращаемое значение.

Вы спросите: "А куда это написать и как же это использовать?" И ответ таков: другие функции нужно объявлять выше функции \lcpp{main} (то есть между \lcpp{using namespace std;} и \lcpp{int main()}). А использовать нужно так: в нашей старой программе вместо:

\cpp{4}{1}

Можно написать:

\cpp{4}{1}

И всё будет работать также, как и раньше!

По аналогии с циклами и условиями, внутри функции создаётся своя область видимости, и поэтому использовать \lcpp{value} внутри \lcpp{main} нельзя.

Теперь можно считать, что основной синтаксис Вы знаете. Остаётся лишь узнать циклы по контейнерам, но это будет в теме контейнеров.

