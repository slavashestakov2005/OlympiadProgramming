\head{Пары и массивы}
В одном из прошлых блоков мы пытались найти корни квадратного уравнения. Там мы поняли, что в зависимости от знака дискриминанта, у уравнения может быть разное количество действительных корней, и поэтому у нас возникла проблема, что мы не знаем типа данных, который бы позволил нам использовать тернарный оператор. В этом же блоке мы постараемся исправить данную проблему.

Начнём, пожалуй, с более частного случая. Пусть нам нужно как-то хранить пару чисел в одной переменной (это могут быть, например, координаты точки на плоскости, или те же корни квадратного уравнения). Для таких целей в C++ придумали тип данных \lcpp{pair}, и для его использования нужно подключить соответствующий файл:

\cpp{6}{1}

После того, как мы подключили нужный файл, можно и начать пользоваться парами, делается это вот так:

\cpp{6}{5}

В строке №1 мы объявляем две переменных, хранящих пару из двух \lcpp{int}. Такое (\lcpp{pair<int, int>}) длинное название типа может несколько пугать, но если в нём разобраться, то всё должно стать понятно. \lcpp{pair} мы пишет потому, что хотим получить пару, а название типов внутри \lcpp{<>} — это типы для соответствующих полей пары (первый тип — для \lcpp{first}, второй — для \lcpp{second}). Причина, по которой нужно писать именно \lcpp{<>} — это \term{шаблоны}. Если коротко, то в C++ они пишутся всегда, когда нужно объявить какой-то сложный тип, содержащий простые. 

Также паре можно присваивать значение, если указать его в фигурных скобках. Если никакое значение не указывать, то присваивается значение по умолчанию (для \lcpp{int} это \lcpp{0}). С помощью точки можно обращаться к частям пары: к её первому (\lcpp{x.first}) или второму (\lcpp{x.second}) элементам. С элементами пар можно работать как с обычными переменными.

Обобщением пар в C++ являются кортежи (\lcpp{tuple}). В них можно хранить не две, а сколько угодно переменных. Во-первых, для использования \lcpp{tuple} вновь придётся подключить одноимённый файл:

\cpp{6}{1}

И после этого кортежи можно использовать (но чуть более хитрым образом, чем пары):

\cpp{6}{6}

С объявлением типа должно быть более-менее всё понятно, здесь, так же, как и с парами, первые тип достанется первой переменной, второй - второй и т.д. Что же касается получения элементов кортежа, то нужно использовать \lcpp{get<1>(t)}, потому что \lcpp{get} является \term{шаблонной функцией} и часть аргументов таких функций может передаваться в \lcpp{<>}.

Теперь, формально, мы умеем хранить в одной переменной столько значений, сколько нужно (достаточно написать побольше типов для \lcpp{tuple}). Но что делать, если нам вдруг понадобится хранить 200 целочисленных переменных, не серьёзно же повторять один и тот же тип \lcpp{int} 200 раз? А если, вдруг, переменных окажется не 200, а столько, сколько введёт пользователь? Справиться с этим всем призваны массивы.

Массивы были ещё в C, поэтому и их использование и создание не сложное. Даже подключать ничего не надо! Давайте снова придумаем какую-нибудь простую задачку. Пусть пользователь вводит сначала число $n$, а потом вводит $n$ чисел и их нужно вывести в обратном порядке. Что ж, приступим к решению!

Для начала нужно считать \lcpp{n} и создать массив для того, чтобы пользователь его заполнил:

\cpp{6}{3}

Можно видеть, что, во-первых, массивы могут иметь размер, не указанный в коде (для \lcpp{tuple} мы в коде прописывали, сколько он будет хранить значений). Во-вторых понятно, как создаётся массив: сначала идёт тип данных, которые он будет хранить (\lcpp{int}), потом его название (\lcpp{arr}) и в конце внутри \lcpp{[]} идёт его размер (\lcpp{n}). Также стоит добавить, что массив, в отличии от пар и кортежей, хранит значения только одного типа.

Теперь можем и решить саму задачу:

\cpp{6}{2}

Из этого примера видно, что обращение к элементам массива выглядит как \lcpp{arr[i]} и с этим элементами можно делать всё, что мы раньше делали с обычными переменными.

Кроме того, если Вы хотите сразу присвоить массиву значения, то можете не указывать его размер и компьютер сам посчитает число элементов:

\cpp{6}{1}

Теперь можно считать, что пары, кортежи и массивы нами изучены. И мы даже сможем сохранить два корня квадратного уравнения с помощью одной переменной (причём можно использовать все три изученных способа). Но вот если мы захотим всегда сохранять все корни уравнения в одну переменную, то у нас это не получится (потому что у пройденных типов размер постоянен после объявления, а мы хотим сначала объявить переменную, а потом в ней сохранить нужное количество корней уравнения). И для этого в C++ есть решение: \lcpp{vector}!

Во-первых, нам, как обычно, понадобится подключить специальный файл:

\cpp{6}{1}

Во-вторых, мы можем создавать переменные с типом \lcpp{vector};

\cpp{6}{1}

Здесь тип данных внутри \lcpp{<>} это тот, тип, который будет храниться внутри \lcpp{vector} (а нашем случае — \lcpp{int}), а после тип, как обычно идёт название переменной (у нас это \lcpp{vec}). 

Если хочется, то можно сразу задать элементы у \lcpp{vector}, делается это также, как и с предыдущими типами:

\cpp{6}{1}

Теперь посмотрим на те функции, которые есть у \lcpp{vector}. Сначала те, которые мы уже видели у строк:

\cpp{6}{11}

И в целом это все основные методы, которые есть у \lcpp{vector}.

Также стоит обратить внимание, что если не аккуратно использовать индексы, то может возникнуть \term{неопределённое поведение}. Например, в этой ситуации:

\cpp{6}{1}

Стандартом C++ не описывается, что происходит в таком случае: программа может как сломаться, так и вывести какое-то значение, которое компьютер хранит в нужном участке памяти. Но если Вы не хотите следить за индексами, то у \lcpp{vector} (а также у \lcpp{string}) есть метод \lcpp{at}:

\cpp{6}{2}
 
На этом изучение \lcpp{vector} закончено, и мы наконец-то сможем записать корни квадратного уравнения в одну переменную, причём это всё можно не сложно сделать в функции! Вот как она может выглядеть:

\cpp{6}{9}

И использоваться она может вот так:

\cpp{6}{4}

Таким образом, у нас получилась рабочая программа. Но она ещё не совершенна, а именно, можно написать вывод переменных чуть короче. Это называется \term{range-based for loop} и появилось в стандарте 2011-го года. Пользоваться этим нужно так:

\cpp{6}{1}

Такая программа перебирает переменной \lcpp{x} все элементы из переменной \lcpp{v}. Чтобы такой циклы сработал переменная \lcpp{v} должна иметь методы \lcpp{v.begin()} и \lcpp{v.end()}, возвращающие итераторы, чтобы компьютер понял в каком месте памяти хранятся элементы, которые нужно перебрать. При желании можно перебрать элементы вектора с помощью только итераторов:

\cpp{6}{1}

Здесь можно видеть, что тип у итератора достаточно длинный (\lcpp{vector<double>::iterator}), поэтому в C++11 придумали специальный тип \lcpp{auto}. Его можно давать любой переменный, которой сразу с объявлением присваивается и значение. Тогда компьютер автоматически понимает, что у переменной должен быть такой же тип, как и у присваиваемого значения, и сам \term{выводит тип}. Пользоваться \lcpp{auto} можно так:

\cpp{6}{3}

Так же \term{range-based for loop} вполне работает и для типа \lcpp{string}, и для массивов. Но вот для \lcpp{pair} и \lcpp{tuple} он работать не будет, потому что кортежи и пары потенциально могут хранить одновременное переменные разных типов, и поэтому компилятор не сможет \term{вывести тип}.

А теперь посмотрите на этот код и скажите, что он выведет:

\cpp{6}{10}

Все, кто считают, что выведутся введённые числа - не правы. Предположение, что получится \lcpp{n} нулей — тоже не верно (хотя и ближе к истине, потому что для \lcpp{vector<int>} так бы и получилось). На самом деле выведутся... \lcpp{n} случайных чисел!

Так происходит, потому что по умолчанию в переменную \lcpp{x} записывается копия элементов, а не они сами. Поэтому если нужно в цикле менять значение элементов контейнера, то нужно добавить всего один символ \lcpp{&} (зато какой — на крендель похожий). Отредактированная строка ввода будет выглядеть вот так:

\cpp{6}{1}

Теперь можно считать, что мы познакомились с циклом по контейнеру и наконец-то смогли красиво найти все корни квадратного уравнения. Будем считать, что это успех!
